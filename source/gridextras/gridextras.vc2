*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="gridextras.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS checkform AS timer 
 	*< CLASSDATA: Baseclass="timer" Timestamp="" Scale="Pixels" Uniqueid="" />

	Height = 23
	Name = "checkform"
	Width = 23
	
	PROCEDURE Timer
		LOCAL lnDifference, lnIntervalWas
		m.lnIntervalWas = This.Interval
		this.Interval = 0
		TRY && Ignor errors for this feature (though there shouldn't be any errors thrown)
			m.lnDifference = SECONDS() - Thisform.LastUserAction
			IF MROW(ThisForm.Name,3) = -1 OR MCOL(ThisForm.Name,3) = -1
				IF m.lnDifference >= Thisform.GridExtraObject.FadeWait
					IF This.Parent._InForm
						This.Parent._InForm = .F.
						This.Parent.tmrFadeForm.Interval = 50
						This.Parent._Fade = 255
					ENDIF
				ELSE
					IF !This.Parent._InForm
						This.Parent._InForm = .T.
						This.Parent.tmrFadeForm.Interval = 50
					ENDIF
				ENDIF
			ELSE
				IF !This.Parent._InForm
					This.Parent._InForm = .T.
					This.Parent.tmrFadeForm.Interval = 50
				ENDIF
			ENDIF
		CATCH
		ENDTRY
		this.Interval = m.lnIntervalWas
	ENDPROC

ENDDEFINE

DEFINE CLASS fadeform AS timer 
 	*< CLASSDATA: Baseclass="timer" Timestamp="" Scale="Pixels" Uniqueid="" />

	Height = 23
	Name = "fadeform"
	Width = 23
	
	PROCEDURE Timer
		LOCAL lnFadeLevel, lnIntervalWas
		m.lnIntervalWas = This.Interval
		this.Interval = 0
		m.lnFadeLevel = MAX(MIN(This.Parent.GridExtraObject.FadeLevel, 255), 0)
		IF This.Parent._InForm
			This.Parent._Fade = MIN(This.Parent._Fade + 60, 255)
		ELSE
			This.Parent._Fade = MAX(This.Parent._Fade - 20, m.lnFadeLevel)
		ENDIF
		
		_Sol_SetLayeredWindowAttributes(thisform.hwnd, 0, This.Parent._Fade, 2)
		
		IF m.lnFadeLevel > 254 OR !BETWEEN(This.Parent._Fade,m.lnFadeLevel + 1, 254)
			This.Interval = 0
		ENDIF
		this.Interval = m.lnIntervalWas
	ENDPROC

ENDDEFINE

DEFINE CLASS gridcolumns AS form 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="grdColumns" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdColumns.Column1.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdColumns.Column1.Check1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdColumns.Column2.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdColumns.Column2.Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Label1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdExit" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdUp" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdDown" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Label2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtColumnWidth" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Shape6" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Label3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkSelectAll" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: checkresizemove		&& INTERNAL USE: Used by the columns form to determine whether a column in the target grid is allowed to resize or move (column properties resizable and movable).
		*m: fillgrid		&& INTERNAL USE: Used by the columns form to fill the grid (columncursorname) with information regarding the columns in the target grid.
		*m: movecolumn		&& INTERNAL USE: Used by the columns form to move columns up and down based on their columnorder. Parameter that is sent determines direction of move like SKIP in a table (1 = Down, -1 = Up).
		*p: columncursorname		&& INTERNAL USE: Used by the columns form to specify a unique cursor name for displaying in the grid.
		*p: gridobject		&& INTERNAL USE: Used by the columns form to hold a reference to the target grid that was sent in when the columns form object was created.
	*</DefinedPropArrayMethod>

	AlwaysOnTop = .T.
	AutoCenter = .T.
	Caption = "Choose Columns"
	columncursorname = 		&& INTERNAL USE: Used by the columns form to specify a unique cursor name for displaying in the grid.
	DataSession = 2
	DoCreate = .T.
	gridobject = .NULL.		&& INTERNAL USE: Used by the columns form to hold a reference to the target grid that was sent in when the columns form object was created.
	Height = 417
	Name = "gridcolumns"
	Width = 360

	ADD OBJECT 'chkSelectAll' AS checkbox WITH ;
		Alignment = 0, ;
		AutoSize = .F., ;
		BackStyle = 0, ;
		Caption = " Select All", ;
		Height = 17, ;
		Left = 19, ;
		Name = "chkSelectAll", ;
		TabIndex = 8, ;
		Top = 24, ;
		Value = .F., ;
		Width = 71
		*< END OBJECT: BaseClass="checkbox" />

	ADD OBJECT 'cmdDown' AS commandbutton WITH ;
		Anchor = 9, ;
		Caption = "\<Down", ;
		Height = 32, ;
		Left = 264, ;
		Name = "cmdDown", ;
		Picture = arrow_down_blue.png, ;
		PictureMargin = 2, ;
		PicturePosition = 4, ;
		TabIndex = 4, ;
		Top = 78, ;
		Width = 84
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdExit' AS commandbutton WITH ;
		Anchor = 12, ;
		Caption = "\<Close ", ;
		Height = 32, ;
		Left = 264, ;
		Name = "cmdExit", ;
		Picture = exit.png, ;
		PictureMargin = 2, ;
		PicturePosition = 4, ;
		TabIndex = 9, ;
		Top = 376, ;
		Width = 84
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdUp' AS commandbutton WITH ;
		Anchor = 9, ;
		Caption = "\<Up", ;
		Height = 32, ;
		Left = 264, ;
		Name = "cmdUp", ;
		Picture = arrow_up_blue.png, ;
		PictureMargin = 2, ;
		PicturePosition = 4, ;
		TabIndex = 3, ;
		Top = 43, ;
		Width = 84
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'grdColumns' AS grid WITH ;
		AllowHeaderSizing = .F., ;
		AllowRowSizing = .F., ;
		Anchor = 15, ;
		ColumnCount = 2, ;
		DeleteMark = .F., ;
		GridLines = 0, ;
		HeaderHeight = 0, ;
		Height = 273, ;
		HighlightBackColor = 255,255,128, ;
		HighlightForeColor = 0,0,0, ;
		HighlightRowLineWidth = 0, ;
		HighlightStyle = 2, ;
		Left = 13, ;
		Name = "grdColumns", ;
		Panel = 1, ;
		RecordMark = .F., ;
		ScrollBars = 2, ;
		SplitBar = .F., ;
		TabIndex = 2, ;
		Top = 44, ;
		Width = 240, ;
		Column1.Alignment = 2, ;
		Column1.Name = "Column1", ;
		Column1.Sparse = .F., ;
		Column1.Width = 23, ;
		Column2.Name = "Column2", ;
		Column2.ReadOnly = .T., ;
		Column2.Width = 195
		*< END OBJECT: BaseClass="grid" />

	ADD OBJECT 'grdColumns.Column1.Check1' AS checkbox WITH ;
		Alignment = 0, ;
		Caption = "", ;
		Centered = .T., ;
		Height = 17, ;
		Left = 10, ;
		Name = "Check1", ;
		Top = 54, ;
		Width = 60
		*< END OBJECT: BaseClass="checkbox" />

	ADD OBJECT 'grdColumns.Column1.Header1' AS header WITH ;
		Caption = "", ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'grdColumns.Column2.Header1' AS header WITH ;
		Caption = "Columns", ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'grdColumns.Column2.Text1' AS textbox WITH ;
		BackColor = 255,255,255, ;
		BorderStyle = 0, ;
		ForeColor = 0,0,0, ;
		Margin = 0, ;
		Name = "Text1", ;
		ReadOnly = .T.
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'Label1' AS label WITH ;
		Anchor = 3, ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = "Select the columns you want to display.", ;
		Height = 17, ;
		Left = 13, ;
		Name = "Label1", ;
		TabIndex = 1, ;
		Top = 8, ;
		Width = 216
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'Label2' AS label WITH ;
		Anchor = 6, ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = "Width of selected column (in pixels):", ;
		Height = 17, ;
		Left = 13, ;
		Name = "Label2", ;
		TabIndex = 6, ;
		Top = 332, ;
		Width = 199
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'Label3' AS label WITH ;
		Alignment = 2, ;
		Anchor = 9, ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = "Column Position", ;
		Height = 32, ;
		Left = 283, ;
		Name = "Label3", ;
		TabIndex = 5, ;
		Top = 115, ;
		Width = 47, ;
		WordWrap = .T.
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'Shape6' AS shape WITH ;
		Anchor = 14, ;
		BackStyle = 0, ;
		Height = 56, ;
		Left = -75, ;
		Name = "Shape6", ;
		SpecialEffect = 0, ;
		Top = 364, ;
		Width = 441, ;
		ZOrderSet = 8
		*< END OBJECT: BaseClass="shape" />

	ADD OBJECT 'txtColumnWidth' AS textbox WITH ;
		Anchor = 6, ;
		DisabledBackColor = 255,255,255, ;
		DisabledForeColor = 128,128,128, ;
		Height = 23, ;
		InputMask = "999", ;
		Left = 213, ;
		Name = "txtColumnWidth", ;
		TabIndex = 7, ;
		Top = 329, ;
		Width = 40
		*< END OBJECT: BaseClass="textbox" />
	
	PROCEDURE checkresizemove		&& INTERNAL USE: Used by the columns form to determine whether a column in the target grid is allowed to resize or move (column properties resizable and movable).
		IF USED(THISFORM.grdColumns.RECORDSOURCE) AND !EOF(THISFORM.grdColumns.RECORDSOURCE)
			THISFORM.cmdUp.ENABLED = EVALUATE(ALLTRIM(THISFORM.grdColumns.RECORDSOURCE) + ".ColMove")
			THISFORM.cmdDown.ENABLED = EVALUATE(ALLTRIM(THISFORM.grdColumns.RECORDSOURCE) + ".ColMove")
			THISFORM.txtColumnWidth.ENABLED = EVALUATE(ALLTRIM(THISFORM.grdColumns.RECORDSOURCE) + ".ColResize")
			THISFORM.txtColumnWidth.REFRESH()
		ENDIF
		
	ENDPROC

	PROCEDURE fillgrid		&& INTERNAL USE: Used by the columns form to fill the grid (columncursorname) with information regarding the columns in the target grid.
		LOCAL lnColumnCounter, loColumn, loHeader, llInvisibleFound
		WITH THIS
			.ColumnCursorName = SYS(2015)
			DO WHILE USED(.ColumnCursorName) && Ensure Uniqueness
				.ColumnCursorName = SYS(2015)
			ENDDO
			CREATE CURSOR (.ColumnCursorName) (isvisible L, columncaption C(150), columnname C(50), ColumnWidth I, ColumnOrd I, ColResize L, ColMove L)
			SELECT (.ColumnCursorName)
			INDEX ON ColumnOrd TAG ColumnOrd ASCENDING
			m.llInvisibleFound = .F.
			FOR m.lnColumnCounter = 1 TO .GridObject.COLUMNCOUNT
				m.loColumn = .GridObject.COLUMNS(m.lnColumnCounter)
				m.loHeader = m.loColumn.CONTROLS(1)
				INSERT INTO (.ColumnCursorName) VALUES (m.loColumn.VISIBLE, m.loHeader.CAPTION, m.loColumn.NAME, m.loColumn.WIDTH, m.loColumn.COLUMNORDER, m.loColumn.RESIZABLE, m.loColumn.MOVABLE)
				IF !m.llInvisibleFound AND !m.loColumn.VISIBLE
					m.llInvisibleFound = .T.
				ENDIF
			NEXT
			GO TOP IN (.ColumnCursorName)
			.grdColumns.RECORDSOURCE = .ColumnCursorName
			.grdColumns.Column1.CONTROLSOURCE = (.ColumnCursorName + ".IsVisible")
			.grdColumns.Column2.CONTROLSOURCE = (.ColumnCursorName + ".ColumnCaption")
			IF !EOF(.ColumnCursorName)
				.txtColumnWidth.CONTROLSOURCE = (.ColumnCursorName + ".ColumnWidth")
			ENDIF
			thisform.chkSelectAll.value = !m.llInvisibleFound
			thisform.chkSelectAll.Refresh()
		ENDWITH
		
	ENDPROC

	PROCEDURE Init
		LPARAMETERS toGridObject
		THISFORM.ICON = _SCREEN.ICON
		THISFORM.GridObject = m.toGridObject
		THISFORM.FillGrid()
		THISFORM.CheckResizeMove()
		THISFORM.MINWIDTH = THISFORM.WIDTH
		THISFORM.MINHEIGHT = THISFORM.HEIGHT
		
	ENDPROC

	PROCEDURE Load
		Set Deleted On
		Set Console Off
		Set Talk Off
		Set Status Off
		Set Multilocks On
		Set Exclusive Off
		Set Seconds Off
		Set SQLBUFFERING On
		Set Safety Off
		Set Reprocess To 3
	ENDPROC

	PROCEDURE movecolumn		&& INTERNAL USE: Used by the columns form to move columns up and down based on their columnorder. Parameter that is sent determines direction of move like SKIP in a table (1 = Down, -1 = Up).
		LPARAMETERS tnColumnSkip
		LOCAL lnColumnOrderWas, lnColumnOrderIs
		IF !EOF(THISFORM.ColumnCursorName)
			m.lnColumnOrderWas = EVALUATE(THISFORM.ColumnCursorName + ".ColumnOrd")
			m.lnColumnOrderIs = m.lnColumnOrderWas + m.tnColumnSkip
			IF SEEK(m.lnColumnOrderIs, THISFORM.ColumnCursorName, "ColumnOrd")
				REPLACE ColumnOrd WITH -1 FOR ColumnOrd = m.lnColumnOrderIs IN (THISFORM.ColumnCursorName)
				REPLACE ColumnOrd WITH m.lnColumnOrderIs FOR ColumnOrd = m.lnColumnOrderWas IN (THISFORM.ColumnCursorName)
				REPLACE ColumnOrd WITH m.lnColumnOrderWas FOR ColumnOrd = -1 IN (THISFORM.ColumnCursorName)
				IF !SEEK(m.lnColumnOrderIs, THISFORM.ColumnCursorName, "ColumnOrd")
					GO TOP IN (THISFORM.ColumnCursorName)
				ENDIF
			ELSE
				IF !SEEK(m.lnColumnOrderWas, THISFORM.ColumnCursorName, "ColumnOrd")
					GO TOP IN (THISFORM.ColumnCursorName)
				ENDIF
			ENDIF
			THISFORM.grdColumns.REFRESH()
		ENDIF
		
	ENDPROC

	PROCEDURE QueryUnload
		NODEFAULT
		THISFORM.cmdExit.CLICK()
		
	ENDPROC

	PROCEDURE chkSelectAll.Valid
		LOCAL llValue
		m.llValue = this.Value
		replace ALL isvisible WITH m.llValue IN (Thisform.ColumnCursorName)
		GO TOP IN (Thisform.ColumnCursorName)
		Thisform.grdColumns.Refresh()
	ENDPROC

	PROCEDURE cmdDown.Click
		THISFORM.MoveColumn(1)
		
	ENDPROC

	PROCEDURE cmdExit.Click
		LOCAL loColumn, lnSelectWas
		
		m.lnSelectWas = SELECT(0)
		
		SELECT (THISFORM.ColumnCursorName)
		LOCATE FOR IsVisible
		IF !FOUND()
			*!* At least one column must still be visible
			*!* You could show the user a message here, but
			*!* as a default action let's just make the first column
			*!* visible.
			GO TOP IN (THISFORM.ColumnCursorName)
			replace isvisible WITH .T. IN (THISFORM.ColumnCursorName)
		ENDIF
		
		SCAN ALL
			m.loColumn = EVALUATE("Thisform.GridObject." + ALLTRIM(columnname))
			IF m.loColumn.VISIBLE != IsVisible
				m.loColumn.VISIBLE = IsVisible
			ENDIF
			IF m.loColumn.COLUMNORDER != ColumnOrd
				m.loColumn.COLUMNORDER = ColumnOrd
			ENDIF
			IF m.loColumn.WIDTH != ColumnWidth
				m.loColumn.WIDTH = ColumnWidth
			ENDIF
		ENDSCAN
		
		SELECT (m.lnSelectWas)
		THISFORM.RELEASE()
		
	ENDPROC

	PROCEDURE cmdUp.Click
		THISFORM.MoveColumn(-1)
		
	ENDPROC

	PROCEDURE grdColumns.AfterRowColChange
		LPARAMETERS nColIndex
		IF DODEFAULT(m.nColIndex)
			THISFORM.CheckResizeMove()
		ENDIF
		
	ENDPROC

	PROCEDURE Shape6.Init
		THIS.ZORDER(1)
		
	ENDPROC

ENDDEFINE

DEFINE CLASS gridcolumnstoplevel AS gridcolumns OF "gridextras.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	DoCreate = .T.
	Name = "gridcolumnstoplevel"
	ShowWindow = 2
	cmdDown.Name = "cmdDown"
	cmdExit.Name = "cmdExit"
	cmdUp.Name = "cmdUp"
	grdColumns.Column1.Check1.Alignment = 0
	grdColumns.Column1.Check1.Name = "Check1"
	grdColumns.Column1.Header1.Name = "Header1"
	grdColumns.Column1.Name = "Column1"
	grdColumns.Column2.Header1.Name = "Header1"
	grdColumns.Column2.Name = "Column2"
	grdColumns.Column2.Text1.Name = "Text1"
	grdColumns.Name = "grdColumns"
	LABEL1.Name = "LABEL1"
	Label2.Name = "Label2"
	Label3.Name = "Label3"
	SHAPE6.Name = "SHAPE6"
	TXTCOLUMNWIDTH.Name = "TXTCOLUMNWIDTH"

ENDDEFINE

DEFINE CLASS gridcustomfilter AS container 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Combo1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Text2" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: clearfiltersettings		&& INTERNAL USE: Used to clear any information that has been previously selected, thus setting the controls in this container back to their defaults of Blank.
		*m: controlsourcetype_assign		&& INTERNAL USE: When the controlsourcetype is assigned the default values for Text1 and Text2 are determined.
		*m: filterstring_access		&& INTERNAL USE: Used to return the filter string that was produced by this container based on the type of the target column's controlsource.
		*m: operatorchanged		&& INTERNAL USE: Handles the visibility of Text1 and Text2 controls based on whether the user has made an operator (Combo1) selection.
		*m: selectall		&& INTERNAL USE: Ensure's that when an operator (Combo1) is selected by the user in this container that the Filter selection grid on the Search/Filter form is in Select All state. Cannot have both selection filtering and operator filtering.
		*m: setup		&& INTERNAL USE: Used to fill the rowsource for Combo1 and set some initial values for this container.
		*p: columncontrolsource		&& INTERNAL USE: Used to hold the value of the target column's controlsource.
		*p: controlsourcetype		&& INTERNAL USE: Used to specify and hold the VFP type of the target column's controlsource.
		*p: filterstring		&& INTERNAL USE: See FilterString_Access.
		*p: interactivechangecombofiring		&& INTERNAL USE: Used to ensure that the Combo1 interactivechange event doesn't fire more than once when the user makes a selection.
		*p: uniquecursorname		&& INTERNAL USE: Used to hold the unique cursor name that is used as the rowsource for Combo1.
	*</DefinedPropArrayMethod>

	BackStyle = 0
	BorderWidth = 0
	columncontrolsource = 		&& INTERNAL USE: Used to hold the value of the target column's controlsource.
	controlsourcetype = C		&& INTERNAL USE: Used to specify and hold the VFP type of the target column's controlsource.
	filterstring = 		&& INTERNAL USE: See FilterString_Access.
	Height = 76
	interactivechangecombofiring = .F.		&& INTERNAL USE: Used to ensure that the Combo1 interactivechange event doesn't fire more than once when the user makes a selection.
	Name = "gridcustomfilter"
	uniquecursorname = 		&& INTERNAL USE: Used to hold the unique cursor name that is used as the rowsource for Combo1.
	Width = 192

	ADD OBJECT 'Combo1' AS combobox WITH ;
		Height = 24, ;
		Left = 1, ;
		Name = "Combo1", ;
		RowSourceType = 1, ;
		Style = 2, ;
		Top = 1, ;
		Width = 190
		*< END OBJECT: BaseClass="combobox" />

	ADD OBJECT 'Text1' AS textbox WITH ;
		Format = "K", ;
		Height = 23, ;
		Left = 1, ;
		Name = "Text1", ;
		SelectOnEntry = .T., ;
		Top = 27, ;
		Visible = .F., ;
		Width = 190
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'Text2' AS textbox WITH ;
		Format = "K", ;
		Height = 23, ;
		Left = 1, ;
		Name = "Text2", ;
		SelectOnEntry = .T., ;
		Top = 52, ;
		Visible = .F., ;
		Width = 190
		*< END OBJECT: BaseClass="textbox" />
	
	PROCEDURE clearfiltersettings		&& INTERNAL USE: Used to clear any information that has been previously selected, thus setting the controls in this container back to their defaults of Blank.
		WITH THIS
			.combo1.LISTINDEX = 1
			.controlsourcetype = .controlsourcetype
		ENDWITH
		
	ENDPROC

	PROCEDURE controlsourcetype_assign		&& INTERNAL USE: When the controlsourcetype is assigned the default values for Text1 and Text2 are determined.
		LPARAMETERS vNewVal
		
		LOCAL lvDefaultValue
		
		DO CASE
			CASE INLIST(m.vNewVal, "C", "M")
				m.lvDefaultValue = ""
			CASE INLIST(m.vNewVal, "N", "Y")
				m.lvDefaultValue = 0.00
			CASE m.vNewVal = "D"
				m.lvDefaultValue = {}
			CASE m.vNewVal = "T"
				m.lvDefaultValue = {/:}
			CASE m.vNewVal = "L"
				m.lvDefaultValue = .T.
		ENDCASE
		WITH THIS
			.text1.VALUE = m.lvDefaultValue
			.text2.VALUE = m.lvDefaultValue
			.text1.REFRESH()
			.text2.REFRESH()
			.ControlSourceType = m.vNewVal
		ENDWITH
	ENDPROC

	PROCEDURE Destroy
		USE IN SELECT(THIS.UniqueCursorName)
		DODEFAULT()
		
	ENDPROC

	PROCEDURE filterstring_access		&& INTERNAL USE: Used to return the filter string that was produced by this container based on the type of the target column's controlsource.
		LOCAL lcFilterString, lnFilterType, lcAtCommand
		
		m.lcFilterString = ""
		IF THISFORM.GridExtraObject.CaseSensitive
			m.lcAtCommand = "AT("
		ELSE
			m.lcAtCommand = "ATC("
		ENDIF
		WITH THIS
			IF !EOF(.uniquecursorname) AND .combo1.LISTINDEX != 1
				m.lnFilterType = EVALUATE(.uniquecursorname + ".criteria")
				DO CASE
					CASE m.lnFilterType = 1
						m.lcFilterString = m.lcAtCommand + "[" + ALLTRIM(.text1.VALUE) + "], LEFT(" + .columncontrolsource + "," + TRANSFORM(LEN(ALLTRIM(.text1.VALUE))) + ")) > 0"
					CASE m.lnFilterType = 2
						m.lcFilterString = m.lcAtCommand + "[" + ALLTRIM(.text1.VALUE) + "], " + .columncontrolsource + ") > 0"
					CASE m.lnFilterType = 3
						DO CASE
							CASE INLIST(.controlsourcetype, "C", "M")
								m.lcFilterString = .columncontrolsource + "=[" + ALLTRIM(TRANSFORM(.text1.VALUE)) + "]"
							CASE INLIST(.controlsourcetype, "D", "T")
								m.lcFilterString = .columncontrolsource + "={" + ALLTRIM(TRANSFORM(.text1.VALUE)) + "}"
							OTHERWISE
								m.lcFilterString = .columncontrolsource + "=" + ALLTRIM(TRANSFORM(.text1.VALUE))
						ENDCASE
					CASE m.lnFilterType = 4
						IF INLIST(.controlsourcetype, "D", "T")
							m.lcFilterString = .columncontrolsource + ">{" + ALLTRIM(TRANSFORM(.text1.VALUE)) + "}"
						ELSE
							m.lcFilterString = .columncontrolsource + ">" + ALLTRIM(TRANSFORM(.text1.VALUE))
						ENDIF
					CASE m.lnFilterType = 5
						IF INLIST(.controlsourcetype, "D", "T")
							m.lcFilterString = .columncontrolsource + "<{" + ALLTRIM(TRANSFORM(.text1.VALUE)) + "}"
						ELSE
							m.lcFilterString = .columncontrolsource + "<" + ALLTRIM(TRANSFORM(.text1.VALUE))
						ENDIF
					CASE m.lnFilterType = 6
						IF INLIST(.controlsourcetype, "D", "T")
							m.lcFilterString = "Between(" + .columncontrolsource + ",{" + ALLTRIM(TRANSFORM(.text1.VALUE)) + "},{"  + ALLTRIM(TRANSFORM(.text2.VALUE)) + "})"
						ELSE
							m.lcFilterString = "Between(" + .columncontrolsource + "," + ALLTRIM(TRANSFORM(.text1.VALUE)) + ","  + ALLTRIM(TRANSFORM(.text2.VALUE)) + ")"
						ENDIF
				ENDCASE
			ENDIF
		ENDWITH
		
		RETURN m.lcFilterString
		
	ENDPROC

	PROCEDURE operatorchanged		&& INTERNAL USE: Handles the visibility of Text1 and Text2 controls based on whether the user has made an operator (Combo1) selection.
		LOCAL lcControlOne, lcControlTwo
		
		WITH THIS
			IF !EOF(.uniquecursorname) AND .combo1.LISTINDEX != 1
				m.lcControlOne = EVALUATE(.uniquecursorname + ".ctrlone")
				m.lcControlTwo = EVALUATE(.uniquecursorname + ".ctrlTwo")
				.text1.VISIBLE = !EMPTY(m.lcControlOne)
				.text2.VISIBLE = !EMPTY(m.lcControlTwo)
			ELSE
				.text1.VISIBLE = .F.
				.text2.VISIBLE = .F.
			ENDIF
		ENDWITH
	ENDPROC

	PROCEDURE selectall		&& INTERNAL USE: Ensure's that when an operator (Combo1) is selected by the user in this container that the Filter selection grid on the Search/Filter form is in Select All state. Cannot have both selection filtering and operator filtering.
		WITH THISFORM
			IF !.check1.VALUE AND THIS.combo1.LISTINDEX > 1
				.check1.VALUE = .T.
				.check1.VALID()
			ENDIF
		ENDWITH
	ENDPROC

	PROCEDURE setup		&& INTERNAL USE: Used to fill the rowsource for Combo1 and set some initial values for this container.
		LPARAMETERS tcFieldCaption, tcFieldType, tcColumnControlSource
		
		LOCAL lcUniqueCursorName
		
		THIS.columncontrolsource = m.tcColumnControlSource
		m.lcUniqueCursorName = SYS(2015)
		THIS.uniquecursorname = m.lcUniqueCursorName
		CREATE CURSOR (m.lcUniqueCursorName) (usrcaption C(30), datatypes C(30), ctrlone C(30), ctrltwo C(30), criteria I)
		m.tcFieldType = UPPER(m.tcFieldType)
		INSERT INTO (m.lcUniqueCursorName) VALUES ("", "", "", "", 0)
		IF INLIST(m.tcFieldType, "C", "M")
			INSERT INTO (m.lcUniqueCursorName) VALUES ("Begins with", "CM", "Text1", "", 1)
		ENDIF
		IF INLIST(m.tcFieldType, "C", "M")
			INSERT INTO (m.lcUniqueCursorName) VALUES ("Contains", "CM", "Text1", "", 2)
		ENDIF
		IF INLIST(m.tcFieldType, "C", "M", "N", "Y", "L", "D", "T")
			INSERT INTO (m.lcUniqueCursorName) VALUES ("Equals", "CMNYLDT", "Text1", "", 3)
		ENDIF
		IF INLIST(m.tcFieldType, "N", "Y", "D", "T")
			INSERT INTO (m.lcUniqueCursorName) VALUES ("Greater than", "NYDT", "Text1", "", 4)
		ENDIF
		IF INLIST(m.tcFieldType, "N", "Y", "D", "T")
			INSERT INTO (m.lcUniqueCursorName) VALUES ("Less than", "NYDT", "Text1", "", 5)
		ENDIF
		IF INLIST(m.tcFieldType, "N", "Y", "D", "T")
			INSERT INTO (m.lcUniqueCursorName) VALUES ("Between", "NYDT", "Text1", "Text2", 6)
		ENDIF
		GO TOP IN (m.lcUniqueCursorName)
		WITH THIS
			.controlsourcetype = m.tcFieldType
			.combo1.ROWSOURCETYPE = 2
			.combo1.ROWSOURCE = m.lcUniqueCursorName
			.combo1.LISTINDEX = 1
		ENDWITH
	ENDPROC

	PROCEDURE Combo1.GotFocus
		THISFORM.LastUserAction = SECONDS()
		
	ENDPROC

	PROCEDURE Combo1.InteractiveChange
		LOCAL lnListIndexWas
		IF THIS.PARENT.InteractiveChangeComboFiring
			RETURN
		ENDIF
		THISFORM.LastUserAction = SECONDS()
		WITH THIS
			.PARENT.InteractiveChangeComboFiring = .T.
			m.lnListIndexWas = .LISTINDEX
			.PARENT.OperatorChanged()
			.PARENT.SelectAll()
			.LISTINDEX = m.lnListIndexWas
			.REFRESH()
			.PARENT.InteractiveChangeComboFiring = .F.
		ENDWITH
		
	ENDPROC

	PROCEDURE Combo1.ProgrammaticChange
		THIS.INTERACTIVECHANGE()
		
	ENDPROC

	PROCEDURE Text1.GotFocus
		THISFORM.LastUserAction = SECONDS()
		
	ENDPROC

	PROCEDURE Text1.InteractiveChange
		THISFORM.LastUserAction = SECONDS()
		THIS.PARENT.SelectAll()
		
	ENDPROC

	PROCEDURE Text2.GotFocus
		THISFORM.LastUserAction = SECONDS()
		
	ENDPROC

	PROCEDURE Text2.InteractiveChange
		THISFORM.LastUserAction = SECONDS()
		THIS.PARENT.selectall()
		
	ENDPROC

ENDDEFINE

DEFINE CLASS gridextra AS custom 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: addjoiner		&& INTERNAL USE: Adds 'AND' between clauses if necessary.
		*m: applyfilter		&& INTERNAL USE: Applies the GridExtra filter to the recordsource of the target grid.
		*m: applysort		&& INTERNAL USE: Applies the sort (ASC, DESC, NONE) to a column in the target grid.
		*m: bindcolumnevents		&& INTERNAL USE: Binds the resize and move events of the columns to allow grid preferences to be saved appropriately.
		*m: bindgridevents		&& INTERNAL USE: Binds the grid's MouseUp event so that the Parition preference can be saved.
		*m: bindheaderevents		&& INTERNAL USE: Binds the Click and RightClick events of the column headers in the grid for the Sort, context menu, or Search/Filter features.
		*m: checktemplatetable		&& INTERNAL USE: Used to convert earlier versions of the gridextras.dbf.
		*m: clearfilter		&& INTERNAL USE: Clears the current filter arrays.
		*m: clearheadersortimages		&& INTERNAL USE: Clears the current header images.
		*m: columnmoved		&& INTERNAL USE: Fired when a column move event occurs for the target grid.
		*m: columnresize		&& INTERNAL USE: Fired when a column resize event occurs for the target grid.
		*m: copytoexcel		&& INTERNAL USE: Copies the target grid out to an Excel document (XLS, XLSX, XLSM, and XLSB are supported).
		*m: copytoreport
		*m: createcombocursor		&& INTERNAL USE: Creates an internal cursor to hold the list items available in a column in the target grid.
		*m: createscreenreference		&& INTERNAL USE: Creates a public reference to the _Screen. This is part of a workaround for a VFP bug where _Screen.A(1,1) will be normailzed as .A(1,1,_Screen) which causes Filter() to return an invalid filter string if _Screen were to be included.
		*m: getcolumnobject		&& INTERNAL USE: Returns a reference to the column object the user's mouse is currently over.
		*m: getcombocursorname		&& INTERNAL USE: Returns the name of the internal cursor representing the combobox sent in.
		*m: getheaderobject		&& INTERNAL USE: Returns a reference to the header object for the column that the user's mouse is currently over.
		*m: getmydocumentspath
		*m: getsortexpression		&& INTERNAL USE: Returns the sort expression to be used for indexing/sorting a column within the target grid.
		*m: getuserapplicationdatapath		&& INTERNAL USE: Returns the parth to the User's Application Data directory (profile specific AppData on Vista).
		*m: gridmouseup		&& INTERNAL USE: Fires when the target grid's MouseUp event occurs.
		*m: headerclick		&& INTERNAL USE: Fires when the target column header's Click event occurs.
		*m: headerrightclick		&& INTERNAL USE: Fires when the target column header's Rightclick event occurs.
		*m: positionform		&& INTERNAL USE: Used to properly position the Search/Filter form by the target column's header control.
		*m: restorecolumnfilters		&& INTERNAL USE: Used to restore the column filters that were saved as a template by the user.
		*m: restorecolumnsort		&& INTERNAL USE: Used to restore thecolumn sort that were saved as a template by the user.
		*m: restorecustomcolumnfilters		&& INTERNAL USE: Used to restore the custom column filters that were saved as a template by the user.
		*m: restoregridpreferences		&& INTERNAL USE: Used to restore the user's preferences that were saved using the SaveGridPreferences method.
		*m: saveacolumnfilters		&& INTERNAL USE: Used to save column filters.
		*m: savecolumnsort		&& INTERNAL USE: Used to save the column sort.
		*m: savecustomcolumnfilters		&& INTERNAL USE: Used to save the custom column filters.
		*m: savegridpreferences		&& INTERNAL USE: Used to save the user's preferences (columns widths, column order, partition setting, and lockcolumns)
		*m: search		&& INTERNAL USE: Used to help provide the incremental search feature.
		*m: setheaderimages		&& INTERNAL USE: Used to set the proper header pictures for the target grid.
		*m: setheadertag		&& INTERNAL USE: Used to set the header tag based on the order that the table comes in on.
		*m: setup		&& Call this when your target grid is ready for action (has a recordsource, columns, controlsources set, etc.).
		*m: showcolumnsform		&& INTERNAL USE: Used to display the Columns form that is shown when the user clicks the context menu's "More..." item.
		*m: showhidecolumn
		*m: showsearchfilterform		&& INTERNAL USE: Used to display the Search/Filter form that is shown when the user clicks the context menu's "Search/Filter" item.
		*m: showtemplatesform
		*m: templateapply		&& INTERNAL USE: Used by the grid templates screen to apply a user selected template.
		*m: templateclear		&& INTERNAL USE: Used by the grid templates screen when the user selects the blank in the templates combobox to clear any previously selected filters and sorts.
		*m: templatecreateindex		&& This method is called to create the index tag(s) for the gridextras template table.
		*m: templatecreatetable		&& This method is called to create the gridextras template table.
		*m: templatedelete		&& INTERNAL USE: Used by the grid templates screen when the user chooses to delete a selected template.
		*m: templatelocate		&& INTERNAL USE: Used by the grid templates screen to select the template table and locate the template that matches the user's selection.
		*m: templatesave		&& INTERNAL USE: Used by the grid templates screen to save a new template to the templates list (see templatetable property)
		*p: allowcolumnvisibility		&& Determines whether the column visibility feature will be available to the user.
		*p: allowgridexport		&& Determines whether the Excel export feature will be available to the user.
		*p: allowgridfilter		&& Determines whether the filter features will be available to the user.
		*p: allowgridpreferences		&& Determines whether the users' grid preferences (column widths, column order, lockcolumns, and partition) will be saved and restored for the grid.
		*p: allowgridreport
		*p: allowgridsort		&& Determines whether the column sort feature will be available to the user.
		*p: allowgridtemplates		&& Determines whether the template feature (save sorts and filters and allow them to be restored later) will be available to the user.
		*p: casesensitive		&& Set this property to determine whether incremental searches and filters are case-sensitive or not.
		*p: columnobject		&& INTERNAL USE: Holds a reference to a column object in the target grid.
		*p: columnsform		&& INTERNAL USE: Used to hold a reference to the gridcolumns form so it doesn't go out of scope.
		*p: columnwasmoved		&& INTERNAL USE: Used as a workaround to keep Header Click events from firing when moving columns.
		*p: combocursorcollection		&& INTERNAL USE: Holds a collection of cursor names used to handle comboboxes in the target grid's columns.
		*p: companyname		&& Set this to the name of your company or the name of your client's company. Used to determine where the grid preferences file is saved.
		*p: currentcolumn		&& INTERNAL USE: Holds a reference to the current column in the target grid.
		*p: currentcombocursorname		&& INTERNAL USE: Holds the name of the internal cursor being used to hold the current combobox's list values.
		*p: fadelevel		&& A numeric value 0 - 255 that controls how much the search/filter form fades. 0 = Completely Transparent, 255 = Completely Opaque (no fade)
		*p: fadewait		&& Time in seconds to wait before fading the search/filter form.
		*p: globalarrayname		&& INTERNAL USE: A unique name that is added as an array property to the _screen to hold the filter strings.
		*p: gridexpression		&& Set this to an expression that evaluates to the target grid. Context of this expression should be the scope or the gridextra class instance (so Thisform.Grid1 would work).
		*p: gridobject		&& INTERNAL USE: Reference to the target grid.
		*p: gridpreferencefile		&& Set this to the name of the gridpreferences file you want gridextras to create/use to save user's preferences in. GetUserApplicationDataPath() + CompanyName + ProductName + GridPreferenceFile determines the full path.
		*p: gridreportfile
		*p: gridtemplatesform
		*p: gridtemplatesimage		&& INTERNAL USE: Holds a reference to the image (gridextratemplates class) that sits in the bottom right of the target grid.
		*p: headerascendingimage		&& Set to the image file that you want gridextra to use as the header picture when the target column is sorted ascending.
		*p: headerdescendingimage		&& Set to the image file that you want gridextra to use as the header picture when the target column is sorted descending.
		*p: headerfilterascendingimage		&& Set to the image file that you want gridextra to use as the header picture when the target column is sorted ascending and a filter is in effect.
		*p: headerfilterdescendingimage		&& Set to the image file that you want gridextra to use as the header picture when the target column is sorted descending and a filter is in effect.
		*p: headerfilterimage		&& Set to the image file that you want gridextra to use as the header picture when the target column has a filter in effect.
		*p: headernosortimage		&& Set to the image file that you want gridextra to use as the header picture when the target column is unable to be sorted.
		*p: indexfile		&& INTERNAL USE: Used to hold the name of the temporary index file that may be used to support sorting columns where a CDX is not available.
		*p: indextag		&& INTERNAL USE: Used to hold the name of the temporary tag that may be used to support sorting columns where a CDX is not available.
		*p: maxcolumnsincontextmenu		&& If AllowColumnVisibility is .T., set this property to the number of columns that you want listed in the header's context menu before a "More..." item is added.
		*p: originalfilter		&& INTERNAL USE: Used to hold the original filter that may have been enforced on the grid's recordsource before the user started adding additional filters using GridExtras.
		*p: parentfield		&& INTERNAL USE: Used to hold the field or expression that should be indexed when sorting a target column.
		*p: parenttable		&& INTERNAL USE: Used to hold the alias that should be indexed when sorting a target column.
		*p: productname		&& Set this to the name of your product or the name of your client's product. Used to determine where the grid preferences file is saved.
		*p: searchandfilterform		&& INTERNAL USE: Used to hold a reference to the Search/Filter form so that it doesn't go out of scope until the user is done with it.
		*p: templateindexcollatesequence
		*p: templatetable		&& Set this property to an expression that evaluates to a full path pointing to the gridextras.dbf (or whatever you named the template table). This would usually be the same as your application's database directory.
		*p: templatetablecodepage
		*p: templatetablefree
		*a: acolumnfilters[1,3]		&& INTERNAL USE: Array used to hold the filter created when the user checks/unchecks values on GridExtraForm.
		*a: customcolumnfilters[1,5]		&& INTERNAL USE: An array of custom filters chosen by the user (Between, Contains, Greater Than, etc.).
	*</DefinedPropArrayMethod>

	allowcolumnvisibility = .T.		&& Determines whether the column visibility feature will be available to the user.
	allowgridexport = .T.		&& Determines whether the Excel export feature will be available to the user.
	allowgridfilter = .T.		&& Determines whether the filter features will be available to the user.
	allowgridpreferences = .T.		&& Determines whether the users' grid preferences (column widths, column order, lockcolumns, and partition) will be saved and restored for the grid.
	allowgridreport = .T.
	allowgridsort = .T.		&& Determines whether the column sort feature will be available to the user.
	allowgridtemplates = .T.		&& Determines whether the template feature (save sorts and filters and allow them to be restored later) will be available to the user.
	casesensitive = .F.		&& Set this property to determine whether incremental searches and filters are case-sensitive or not.
	columnobject = .NULL.		&& INTERNAL USE: Holds a reference to a column object in the target grid.
	columnsform = .NULL.		&& INTERNAL USE: Used to hold a reference to the gridcolumns form so it doesn't go out of scope.
	columnwasmoved = .F.		&& INTERNAL USE: Used as a workaround to keep Header Click events from firing when moving columns.
	combocursorcollection = .NULL.		&& INTERNAL USE: Holds a collection of cursor names used to handle comboboxes in the target grid's columns.
	companyname = MyCompany		&& Set this to the name of your company or the name of your client's company. Used to determine where the grid preferences file is saved.
	currentcolumn = .NULL.		&& INTERNAL USE: Holds a reference to the current column in the target grid.
	currentcombocursorname = 		&& INTERNAL USE: Holds the name of the internal cursor being used to hold the current combobox's list values.
	fadelevel = 150		&& A numeric value 0 - 255 that controls how much the search/filter form fades. 0 = Completely Transparent, 255 = Completely Opaque (no fade)
	fadewait = 1		&& Time in seconds to wait before fading the search/filter form.
	globalarrayname = 		&& INTERNAL USE: A unique name that is added as an array property to the _screen to hold the filter strings.
	gridexpression = Thisform.Grid1		&& Set this to an expression that evaluates to the target grid. Context of this expression should be the scope or the gridextra class instance (so Thisform.Grid1 would work).
	gridobject = .NULL.		&& INTERNAL USE: Reference to the target grid.
	gridpreferencefile = gridprefs.tmp		&& Set this to the name of the gridpreferences file you want gridextras to create/use to save user's preferences in. GetUserApplicationDataPath() + CompanyName + ProductName + GridPreferenceFile determines the full path.
	gridreportfile = (addbs(Sys(2023)) + sys(2015) + ".frx")
	gridtemplatesform = .NULL.
	gridtemplatesimage = .NULL.		&& INTERNAL USE: Holds a reference to the image (gridextratemplates class) that sits in the bottom right of the target grid.
	headerascendingimage = ascendingsort12.bmp		&& Set to the image file that you want gridextra to use as the header picture when the target column is sorted ascending.
	headerdescendingimage = descendingsort12.bmp		&& Set to the image file that you want gridextra to use as the header picture when the target column is sorted descending.
	headerfilterascendingimage = filterAscending12.bmp		&& Set to the image file that you want gridextra to use as the header picture when the target column is sorted ascending and a filter is in effect.
	headerfilterdescendingimage = filterDescending12.bmp		&& Set to the image file that you want gridextra to use as the header picture when the target column is sorted descending and a filter is in effect.
	headerfilterimage = filter12.bmp		&& Set to the image file that you want gridextra to use as the header picture when the target column has a filter in effect.
	headernosortimage = nosort12.bmp		&& Set to the image file that you want gridextra to use as the header picture when the target column is unable to be sorted.
	indexfile = 		&& INTERNAL USE: Used to hold the name of the temporary index file that may be used to support sorting columns where a CDX is not available.
	indextag = 		&& INTERNAL USE: Used to hold the name of the temporary tag that may be used to support sorting columns where a CDX is not available.
	maxcolumnsincontextmenu = 8		&& If AllowColumnVisibility is .T., set this property to the number of columns that you want listed in the header's context menu before a "More..." item is added.
	Name = "gridextra"
	originalfilter = 		&& INTERNAL USE: Used to hold the original filter that may have been enforced on the grid's recordsource before the user started adding additional filters using GridExtras.
	parentfield = 		&& INTERNAL USE: Used to hold the field or expression that should be indexed when sorting a target column.
	parenttable = 		&& INTERNAL USE: Used to hold the alias that should be indexed when sorting a target column.
	productname = MyProduct		&& Set this to the name of your product or the name of your client's product. Used to determine where the grid preferences file is saved.
	searchandfilterform = .NULL.		&& INTERNAL USE: Used to hold a reference to the Search/Filter form so that it doesn't go out of scope until the user is done with it.
	templateindexcollatesequence = MACHINE
	templatetable = ["] + FullPath("gridextras.dbf") + ["]		&& Set this property to an expression that evaluates to a full path pointing to the gridextras.dbf (or whatever you named the template table). This would usually be the same as your application's database directory.
	templatetablecodepage = 1252
	templatetablefree = .T.
	
	PROCEDURE addjoiner		&& INTERNAL USE: Adds 'AND' between clauses if necessary.
		LPARAMETERS tcCurrentFilter, tcFilterNewPart
		LOCAL lcReturn, lcCurrentFilterPart
		m.lcReturn = ""
		IF !EMPTY(m.tcFilterNewPart)
			m.tcFilterNewPart = ALLTRIM(m.tcFilterNewPart)
			m.tcCurrentFilter = ALLTRIM(m.tcCurrentFilter)
			m.lcCurrentFilterPart = RIGHT(m.tcCurrentFilter,1)
			IF m.lcCurrentFilterPart != "(" AND m.tcFilterNewPart != ")"
				DO CASE 
					CASE m.tcFilterNewPart = "(" AND EMPTY(m.tcCurrentFilter)
						m.lcReturn = m.tcFilterNewPart
					CASE m.tcFilterNewPart = "(" AND !EMPTY(m.tcCurrentFilter)
						m.lcReturn = " AND " + m.tcFilterNewPart
					CASE m.lcCurrentFilterPart = ")"
						m.lcReturn = " AND " + m.tcFilterNewPart
					OTHERWISE
						m.lcReturn = " OR " + m.tcFilterNewPart
				ENDCASE
			ELSE
				m.lcReturn = m.tcFilterNewPart
			ENDIF
		ENDIF
		
		RETURN m.lcReturn
	ENDPROC

	PROCEDURE applyfilter		&& INTERNAL USE: Applies the GridExtra filter to the recordsource of the target grid.
		LOCAL lcFilter, lnFilterCounter, lcColumnFilter, lcCurrentFilter, lcCustomFilterString
		IF TYPE("this.GridObject.Name") = "C"
			m.lcCurrentFilter = FILTER(this.GridObject.recordsource)
			*!* Need 8 paranthesis on the right side to handle between() filters correctly
			DO WHILE !EMPTY(STREXTRACT(m.lcCurrentFilter,".AND.(((((((","))))))))",1,4))
				m.lcCurrentFilter = STRTRAN(m.lcCurrentFilter, STREXTRACT(m.lcCurrentFilter,".AND.(((((((","))))))))",1,4),"",-1,-1,1)
			ENDDO
			*!* Need 8 paranthesis on the right side to handle between() filters correctly
			DO WHILE !EMPTY(STREXTRACT(m.lcCurrentFilter,"(((((((","))))))))",1,4))
				m.lcCurrentFilter = STRTRAN(m.lcCurrentFilter, STREXTRACT(m.lcCurrentFilter,"(((((((","))))))))",1,4),"",-1,-1,1)
			ENDDO
			*!* Now 7 paranthesis
			DO WHILE !EMPTY(STREXTRACT(m.lcCurrentFilter,".AND.(((((((",")))))))",1,4))
				m.lcCurrentFilter = STRTRAN(m.lcCurrentFilter, STREXTRACT(m.lcCurrentFilter,".AND.(((((((",")))))))",1,4),"",-1,-1,1)
			ENDDO
			*!* Now 7 paranthesis
			DO WHILE !EMPTY(STREXTRACT(m.lcCurrentFilter,"(((((((",")))))))",1,4))
				m.lcCurrentFilter = STRTRAN(m.lcCurrentFilter, STREXTRACT(m.lcCurrentFilter,"(((((((",")))))))",1,4),"",-1,-1,1)
			ENDDO
			m.lcCurrentFilter = IIF(!EMPTY(m.lcCurrentFilter) and (LEFT(ALLTRIM(m.lcCurrentFilter),1) != "(" or RIGHT(ALLTRIM(m.lcCurrentFilter),1) != ")"), ;
								"(" + m.lcCurrentFilter + ")", m.lcCurrentFilter)
		
			IF ATC(this.globalarrayname,m.lcCurrentFilter) = 0
				this.originalfilter = m.lcCurrentFilter
			ENDIF
			
			m.lcCustomFilterString = ""
			FOR m.lnFilterCounter = 1 TO ALEN(this.customcolumnfilters,1)
				IF !EMPTY(this.customcolumnfilters(m.lnFilterCounter,5))
					m.lcCustomFilterString = m.lcCustomFilterString + IIF(!EMPTY(m.lcCustomFilterString)," AND ", " ") + this.customcolumnfilters(m.lnFilterCounter,5)
				ENDIF
			ENDFOR
			
			this.originalfilter = IIF(!EMPTY(this.originalfilter) and (LEFT(ALLTRIM(this.originalfilter),1) != "(" or RIGHT(ALLTRIM(this.originalfilter),1) != ")"), ;
								"(" + this.originalfilter + ")", this.originalfilter)
			
			IF !EMPTY(m.lcCustomFilterString)
				m.lcFilter = IIF(!EMPTY(this.originalfilter), this.originalfilter + ".AND.(((((((", "(((((((") + m.lcCustomFilterString + ")))))))"
			ELSE
				m.lcFilter = This.originalfilter
			ENDIF
			FOR m.lnFilterCounter = 1 TO ALEN(this.aColumnFilters,1)
				m.lcColumnFilter = this.aColumnFilters(m.lnFilterCounter, 1)
				IF TYPE("m.lcColumnFilter") = "C" AND !EMPTY(m.lcColumnFilter)
					m.lcFilter = m.lcFilter + This.AddJoiner(m.lcFilter, m.lcColumnFilter)
				ENDIF
			ENDFOR
			TRY
				SET FILTER TO &lcFilter IN (this.GridObject.recordsource)
			CATCH
			ENDTRY
			GO TOP IN (this.GridObject.recordsource)
			this.GridObject.refresh()
		ENDIF
	ENDPROC

	PROCEDURE applysort		&& INTERNAL USE: Applies the sort (ASC, DESC, NONE) to a column in the target grid.
		Lparameters tlIsCombobox, toColumnObject, tcTemplateAscending
		Local lnSelectWas, lcSafetyWas, lcSortExpression, ;
			lcControlSource, lcParentField, loColumn, ;
			lnTagNo, llNewColumn, loHeaderObject, ;
			loExc As Exception, lnChangedBufferFrom
		
		m.lnSelectWas = Select()
		
		If Type('m.tcTemplateAscending') != 'C' ;
				OR !Inlist(tcTemplateAscending,'D','A','N')
			m.tcTemplateAscending = 'N'
		Endif
		
		With This
			If Type("m.toColumnObject") = "O"
				m.loColumn = m.toColumnObject
			Else
				m.loColumn = This.GetColumnObject()
			Endif
			If Type("m.loColumn.PARENT.RECORDSOURCE") != "C"
				Return .F.
			Endif
			If !Isnull(.currentcolumn) And m.loColumn.Name = .currentcolumn.Name And Vartype(m.toColumnObject) != "O"
				m.llNewColumn = .F.
			Else
				m.llNewColumn = .T.
				.currentcolumn = m.loColumn
				Release m.loColumn
				m.loColumn = Null
			Endif
			If Type([This.CurrentColumn]) != "O" Or Type([This.CurrentColumn.ControlSource]) != "C"
				*< m.loHeaderObject = .currentcolumn.Controls(1)
		      m.loHeaderObject = .currentcolumn.Header1
				This.ClearHeaderSortImages()
				m.loHeaderObject.Picture = This.HeaderNoSortImage && "navigate_no.png"
				.currentcolumn = Null
				Select (m.lnSelectWas)
				Return .F.
			Endif
			.currentcolumn.SetFocus()
			m.lcControlSource = Evaluate([This.CurrentColumn.ControlSource])
			m.lcParentField = Justext(m.lcControlSource)
			If m.tlIsCombobox Or Empty(Field(m.lcParentField,.currentcolumn.Parent.RecordSource))
				m.lcParentField = m.lcControlSource
				.ParentTable = .currentcolumn.Parent.RecordSource
				Select (.ParentTable)
				m.lnTagNo = 0
			Else
				.ParentTable = Juststem(m.lcControlSource)
				Select (.ParentTable)
				m.lnTagNo = Tagno(m.lcParentField)
			Endif
			If !m.llNewColumn Or m.lnTagNo > 0
				If m.lnTagNo = 0 && we're dealing with an idx
					m.lcParentField = Juststem(.INDEXFILE)
				Endif
				Try
					Do Case
					Case m.tcTemplateAscending = 'D'
						Set Order To (m.lcParentField) In (.ParentTable) Descending
		
					Case m.tcTemplateAscending = 'A'
						Set Order To (m.lcParentField) In (.ParentTable) Ascending
		
					Otherwise
						Set Order To 0 In (.ParentTable)
					Endcase
				Catch
					Set Order To 0 In (.ParentTable)
				Endtry
			Else
				m.lcSortExpression = This.GetSortExpression(m.lcParentField, m.tlIsCombobox)
				If !Empty(m.lcSortExpression)
					m.lcSafetyWas = Set("Safety")
					Set Safety Off && If idx already exists, overwrite it silently
					Try
						m.lnChangedBufferFrom = CursorGetProp("Buffering", .ParentTable)
						If Between(m.lnChangedBufferFrom, 4, 5)
							If Getnextmodified(0, .ParentTable, .T.) = 0
								CursorSetProp("Buffering", 3, .ParentTable) && Must set tables and views to optimistic row buffering in order to create a temp index
							Else
								Messagebox("The system was unable to sort the selected column due to unsaved changes." + Chr(13) ;
									+ "Save your changes and try again.", 64, "Unsaved Changes Detected - Save Required")
								Exit
							Endif
						Endif
						Try
							Index On &lcSortExpression To (.INDEXFILE)
							Do Case
							Case m.tcTemplateAscending = 'D'
								Set Order To (Order(.ParentTable)) Descending
		
							Case m .tcTemplateAscending = 'A'
								Set Order To (Order(.ParentTable)) Ascending
		
							Otherwise
								Set Order To 0 In (.ParentTable)
							Endcase
						Catch
							Set Order To 0 In (.ParentTable)
						Endtry
					Catch To m.loExc
						*< m.loHeaderObject = .currentcolumn.Controls(1)
		            m.loHeaderObject = .currentcolumn.Header1
						m.loHeaderObject.Picture = This.HeaderNoSortImage && "navigate_no.png"
						.currentcolumn = Null
					Finally
						If Used(.ParentTable)
							If Between(m.lnChangedBufferFrom, 4, 5) And !Between(CursorGetProp("Buffering", .ParentTable),4,5)
								CursorSetProp("Buffering", m.lnChangedBufferFrom, .ParentTable)
							Endif
						Endif
					Endtry
					Set Safety &lcSafetyWas && set it back the way we found it
				Endif
			Endif
			If !Isnull(.currentcolumn)
				Go Bottom In (.ParentTable)
				Go Top In (.ParentTable)
				.GridObject.Refresh()
				.currentcolumn.SetFocus()
			Endif
			.GridObject.Refresh()
		Endwith
		Select (m.lnSelectWas)
		Return (!Isnull(This.currentcolumn))
		
	ENDPROC

	PROCEDURE bindcolumnevents		&& INTERNAL USE: Binds the resize and move events of the columns to allow grid preferences to be saved appropriately.
		LPARAMETERS toColumnObject
		BINDEVENT(m.toColumnObject, "Moved", This, "ColumnMoved", 1)
		BINDEVENT(m.toColumnObject, "Resize", This, "ColumnResize", 1)
	ENDPROC

	PROCEDURE bindgridevents		&& INTERNAL USE: Binds the grid's MouseUp event so that the Parition preference can be saved.
		LPARAMETERS toGridObject
		BINDEVENT(m.toGridObject, "MouseUp", This, "GridMouseUp", 1)
	ENDPROC

	PROCEDURE bindheaderevents		&& INTERNAL USE: Binds the Click and RightClick events of the column headers in the grid for the Sort, context menu, or Search/Filter features.
		LPARAMETERS toHeaderObject
		BINDEVENT(m.toHeaderObject, "Click", This, "HeaderClick", 1)
		BINDEVENT(m.toHeaderObject, "RightClick", This, "HeaderRightClick", 1)
	ENDPROC

	PROCEDURE checktemplatetable		&& INTERNAL USE: Used to convert earlier versions of the gridextras.dbf.
		Local lnSelectWas, lcTemplateTable, lcTemplateAlias, llWasUsed
		m.lnSelectWas = Select()
		m.lcTemplateTable = EVALUATE(This.templatetable)
		If VARTYPE(m.lcTemplateTable) = "C" AND File(m.lcTemplateTable)
			m.llWasUsed = .T.
			m.lcTemplateAlias = Juststem(m.lcTemplateTable)
			If !Used(m.lcTemplateAlias)
				m.llWasUsed = .F.
				Use (m.lcTemplateTable) In 0 Shared
			Endif
			If Type(m.lcTemplateAlias + ".sortasc") = "L"
				Use In Select(m.lcTemplateAlias)
				Use (m.lcTemplateTable) In 0 Excl
				Alter Table (m.lcTemplateAlias) Alter Column sortasc C(1)
				Replace All sortasc With Icase(sortasc = "T", "A", sortasc = "F", "D", "N") In (m.lcTemplateAlias)
			ENDIF
			IF !m.llWasUsed
				Use In Select(m.lcTemplateAlias)
			ENDIF
		Endif
		Select (m.lnSelectWas)
		
	ENDPROC

	PROCEDURE clearfilter		&& INTERNAL USE: Clears the current filter arrays.
		LOCAL lcFilter
		m.lcFilter = This.originalfilter
		IF USED(this.GridObject.recordsource)
			SET FILTER TO &lcFilter IN (this.GridObject.recordsource)
			GO TOP IN (this.GridObject.recordsource)
		ENDIF
		this.GridObject.refresh()
		
	ENDPROC

	PROCEDURE clearheadersortimages		&& INTERNAL USE: Clears the current header images.
		LOCAL loHeaderObject, lnCounter, loColumn, lcHeaderImage
		IF TYPE("THIS.currentcolumn.name") = "C"
			FOR m.lnCounter = 1 TO THIS.currentcolumn.parent.columncount
				m.loColumn = THIS.currentcolumn.parent.columns(m.lnCounter)
				*< m.loHeaderObject = m.loColumn.controls(1)
		      m.loHeaderObject = m.loColumn.Header1
				m.lcHeaderImage = UPPER(JUSTFNAME(m.loHeaderObject.picture))
		*!*		IF !EMPTY(m.lcHeaderImage) AND INLIST(m.lcHeaderImage, UPPER(this.HeaderAscendingImage), UPPER(This.HeaderDescendingImage), UPPER(This.HeaderNoSortImage)) 
		*!*			 m.loHeaderObject.picture = ""
		*!*		ENDIF
				IF !EMPTY(m.lcHeaderImage)
				  DO CASE 
				    CASE INLIST(m.lcHeaderImage,UPPER(this.HeaderAscendingImage),UPPER(This.HeaderDescendingImage),UPPER(This.HeaderNoSortImage)) 
				        STORE "" TO m.loHeaderObject.picture, ;
				                    m.loHeaderObject.Tag
				                     
				    CASE INLIST(m.lcHeaderImage, UPPER(this.HeaderFilterAscendingImage), UPPER(This.HeaderFilterDescendingImage)) 
				        m.loHeaderObject.picture = This.HeaderFilterImage
				        m.loHeaderObject.Tag = ""
				  ENDCASE       
				ENDIF
			ENDFOR
		ENDIF
		
	ENDPROC

	PROCEDURE columnmoved		&& INTERNAL USE: Fired when a column move event occurs for the target grid.
		this.columnwasmoved = .T. && workaround to keep header click from firing when user is moving column
		This.savegridpreferences(this.GridObject)
		
	ENDPROC

	PROCEDURE columnresize		&& INTERNAL USE: Fired when a column resize event occurs for the target grid.
		This.savegridpreferences(this.GridObject)
		
	ENDPROC

	PROCEDURE copytoexcel		&& INTERNAL USE: Copies the target grid out to an Excel document (XLS, XLSX, XLSM, and XLSB are supported).
		#DEFINE ALPHANUMERICCHR "ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz1234567890"
		LOCAL lnCounter, loColumn, lcXLSFile, lcSheetName, lcAliasWas, lcGridAlias, ;
			lcExcelFieldList, lcTableFieldList, loHeaderObject, ;
			lcFileName, lcAction, lcPath, loExcelApp, loWorkBook
		LOCAL ARRAY laFieldNames(1,2)
		
		m.lcXLSFile = This.GetMyDocumentsPath() + SYS(2015) + ".xls"
		m.lcXLSFile = PUTFILE("Export to Excel:", m.lcXLSFile, "XLS;XLSX;XLSM;XLSB")
		IF !EMPTY(m.lcXLSFile)
			m.lcAliasWas = ALIAS()
			m.lcGridAlias = THIS.GridObject.RECORDSOURCE
		
			m.lcSheetName = "Sheet1"
			STORE "" TO m.lcExcelFieldList, m.lcTableFieldList
			DIMENSION laFieldNames(THIS.GridObject.COLUMNCOUNT,2)
			FOR m.lnCounter = 1 TO THIS.GridObject.COLUMNCOUNT
				m.loColumn = THIS.GridObject.COLUMNS(m.lnCounter)
				IF m.loColumn.VISIBLE AND m.loColumn.WIDTH > 0
					*< m.loHeaderObject = m.loColumn.CONTROLS(1)
		         m.loHeaderObject = m.loColumn.Header1
					laFieldNames(m.loColumn.columnorder, 1) = m.loColumn.CONTROLSOURCE
					laFieldNames(m.loColumn.columnorder, 2) = ALLTRIM(CHRTRAN(m.loHeaderObject.CAPTION,CHRTRAN(m.loHeaderObject.CAPTION,ALPHANUMERICCHR,""),""))
				ENDIF
			ENDFOR
		
			FOR m.lnCounter = 1 TO ALEN(laFieldNames,1)
				IF !EMPTY(laFieldNames(m.lnCounter,1)) AND !EMPTY(laFieldNames(m.lnCounter,2))
					m.lcExcelFieldList = m.lcExcelFieldList + IIF(!EMPTY(m.lcExcelFieldList), ',', '') ;
						+ laFieldNames(m.lnCounter,2)
					m.lcTableFieldList = m.lcTableFieldList + IIF(!EMPTY(m.lcTableFieldList), ',', '') ;
						+ laFieldNames(m.lnCounter,1)
				ENDIF
			ENDFOR
		
			IF ATC("GRIDEXTRASPROCS", SET("Procedure")) < 1
				SET PROCEDURE TO gridextrasprocs additive
			ENDIF
		
			CopyToExcel(m.lcXLSFile, m.lcSheetName, m.lcGridAlias, m.lcExcelFieldList, m.lcTableFieldList, FILTER(m.lcGridAlias))
			
			IF FILE(m.lcXLSFile)
				m.lcFileName = JUSTFNAME(m.lcXLSFile)
				IF MESSAGEBOX('The file ' + m.lcFileName + CHR(13) + 'was successfully exported.' + CHR(13) +;
						'Would you like to open it now?',36,'EXCEL EXPORT SUCCESSFUL') = 6
					TRY
						m.loExcelApp = CREATEOBJECT("EXCEL.APPLICATION")
						m.loWorkBook = m.loExcelApp.Workbooks.OPEN(m.lcXLSFile)
						m.loExcelApp.VISIBLE = .T.
					CATCH
						MESSAGEBOX("The system encountered a problem opening the Excel document.",64,"Problem Encountered")
					ENDTRY
				ENDIF
			ENDIF
			IF m.lcAliasWas != ALIAS() AND USED(m.lcAliasWas)
				SELECT (m.lcAliasWas)
			ENDIF
		ENDIF
		
	ENDPROC

	PROCEDURE copytoreport
		Lparameters tcFRXName, tnOrientation, tnPaperSize, tnScale
		
		*************************************************************
		**
		**	tnOrientation : 0 = Portrait, 1 = Landscape
		**  tnPaperSize   : 1 = Letter, 5 = Legal
		**  tnScale       : 1 = 100%
		**
		*************************************************************
		Local loGrid As Grid
		Local loColumn As Column
		Local loField As TextBox
		Local loControl As Header
		Local loForm As Form
		Local lnLeft, lnTop, lnMaxHeight, lnPageWidth
		Local loReport As SFReportFile Of SFRepObj/SFRepObj.vcx
		Local loText   As SFReportText Of SFRepObj/SFRepObj.vcx
		Local loField  As SFReportText Of SFRepObj/SFRepObj.vcx
		Local loDetail As SFReportBand Of SFRepObj/SFRepObj.vcx
		Local loPageHeader As SFReportBand Of SFRepObj/SFRepObj.vcx
		Local lcUniqueCursorName, lnSelect
		
		m.tcFRXName     = Evl(m.tcFRXName, This.GridReportFile)
		m.tnOrientation = Evl(m.tnOrientation, 1)
		m.tnScale       = Evl(m.tnScale, 1)
		m.tnPaperSize   = Evl(m.tnPaperSize, 1)
		m.lcUniqueCursorName = SYS(2015)
		DO WHILE USED(m.lcUniqueCursorName)
			m.lcUniqueCursorName = SYS(2015)
		ENDDO	
		m.loGrid = This.GridObject
		
		m.lnSelect = Select(0)
		
		Create Cursor (m.lcUniqueCursorName) ;
			( Expr			m, ;
			TYPE			c(1), ;
			TOP			i, ;
			LEFT			i, ;
			WIDTH			i, ;
			HEIGHT		i, ;
			ORDER			i, ;
			FONTNAME		v(150), ;
			FONTSIZE		i, ;
			FontStyle		i, ;
			FORECOLOR		i, ;
			BACKCOLOR		i, ;
			INPUTMASK		v(100), ;
			ALIGNMENT		i, ;
			CAPTION			v(150), ;
			CaptionFontName	v(150), ;
			CaptionFontSize	i, ;
			CaptionFontStyle	i, ;
			CaptionForeColor	i, ;
			CaptionBackColor	i, ;
			CaptionAlignment	i)
		
		For Each m.loColumn In m.loGrid.Columns FoxObject
			IF TYPE("m.loColumn.Width")="N" AND m.loColumn.Width=0
				LOOP
			ENDIF
			IF TYPE("m.loColumn.Visible")="L" AND !m.loColumn.Visible
				LOOP
			ENDIF
		  	SELECT (m.lcUniqueCursorName)
			Scatter Memo Name m.loData Blank
			With m.loData
				.Order = m.loColumn.ColumnOrder
				.Width = m.loColumn.Width
		
				.Expr = m.loColumn.ControlSource
				.FontName = m.loColumn.FontName
				.FontSize = m.loColumn.FontSize
				.FontStyle = 0
				.FontStyle = .FontStyle + Iif(m.loColumn.FontBold, 1, 0)
				.FontStyle = .FontStyle + Iif(m.loColumn.FontItalic, 2, 0)
				.FontStyle = .FontStyle + Iif(m.loColumn.FontUnderline, 4, 0)
				.FontStyle = .FontStyle + Iif(m.loColumn.FontStrikethru, 8, 0)
				.ForeColor = m.loColumn.ForeColor
				.BackColor = m.loColumn.BackColor
				.Alignment = m.loColumn.Alignment
				.InputMask = m.loColumn.InputMask
		
				For Each m.loControl In m.loColumn.Controls FoxObject
					Do Case
					Case m.loControl.BaseClass = "Header"
						.Caption = m.loControl.Caption
						.CaptionFontName = m.loControl.FontName
						.CaptionFontSize = m.loControl.FontSize
						.CaptionFontStyle = 0
						.CaptionFontStyle = .CaptionFontStyle + Iif(m.loControl.FontBold, 1, 0)
						.CaptionFontStyle = .CaptionFontStyle + Iif(m.loControl.FontItalic, 2, 0)
						.CaptionFontStyle = .CaptionFontStyle + Iif(m.loControl.FontUnderline, 4, 0)
						.CaptionFontStyle = .CaptionFontStyle + Iif(m.loControl.FontStrikethru, 8, 0)
						.CaptionForeColor = m.loControl.ForeColor
						.CaptionBackColor = m.loControl.BackColor
						.CaptionAlignment = m.loControl.Alignment
		
					Case m.loColumn.Sparse = .F. And m.loControl.Name = m.loColumn.CurrentControl AND TYPE("m.loControl.InputMask") = "C"
						.Expr = m.loControl.ControlSource
						.FontName = m.loControl.FontName
						.FontSize = m.loControl.FontSize
						.FontStyle = 0
						.FontStyle = .FontStyle + Iif(m.loControl.FontBold, 1, 0)
						.FontStyle = .FontStyle + Iif(m.loControl.FontItalic, 2, 0)
						.FontStyle = .FontStyle + Iif(m.loControl.FontUnderline, 4, 0)
						.FontStyle = .FontStyle + Iif(m.loControl.FontStrikethru, 8, 0)
						.ForeColor = m.loControl.ForeColor
						.BackColor = m.loControl.BackColor
						.Alignment = m.loControl.Alignment
						.InputMask = m.loControl.InputMask
					Endcase
				Endfor
				.Type = Type(.Expr)
				.Height = Fontmetric(1, .FontName, .FontSize)
		
				If m.tnScale <> 1
					.FontSize = Round(.FontSize * m.tnScale, 0)
					.Height = Round(.Height * m.tnScale, 0)
					.Width = Round(.Width * m.tnScale, 0)
					.CaptionFontSize = Round(.CaptionFontSize*m.tnScale, 0)
				Endif
		
			Endwith
			Insert Into (m.lcUniqueCursorName) From Name m.loData
		Endfor
		
		Index On Order Tag Order
		Go Top
		m.lnLeft = 0
		m.lnTop = 0
		m.lnMaxHeight = Height
		
		Do Case
		Case m.tnOrientation = 0
			m.lnPageWidth = 8*96
		Case m.tnPaperSize = 1		&& Letter
			m.lnPageWidth = 10.5*96
		Case m.tnPaperSize = 5		&& Legal
			m.lnPageWidth = 13.5*96
		Otherwise
			m.lnPageWidth = 8*96
		Endcase
		
		Scan
			If m.lnLeft+Width > m.lnPageWidth And m.lnLeft <> 0
				m.lnTop = m.lnTop + m.lnMaxHeight + 5
				m.lnLeft = 0
				m.lnMaxHeight = Height
			Endif
			Replace ;
				LEFT        With m.lnLeft, ;
				TOP         With m.lnTop, ;
				FORECOLOR   With Iif(ForeColor=0,-1,ForeColor), ;
				BACKCOLOR   With Iif(BackColor=Rgb(255,255,255),-1,BackColor), ;
				CaptionForeColor With Iif(CaptionForeColor=0,-1,CaptionForeColor)
			m.lnLeft = m.lnLeft + Width + 5
			m.lnMaxHeight = Max(m.lnMaxHeight, Height)
		Endscan
		
		m.loReport = Newobject('SFReportFile', 'SFRepObj/SFRepObj')
		m.loReport.cReportFile  = m.tcFRXName
		m.loReport.cUnits = "I"
		m.loReport.cFontName = 'Arial'
		m.loReport.nOrientation = m.tnOrientation
		m.loReport.nPaperSize = m.tnPaperSize
		
		
		m.loPageHeader = loReport.GetReportBand('Page Header')
		m.loPageHeader.nHeight = 0
		
		m.loDetail = loReport.GetReportBand('Detail')
		m.loDetail.nHeight = 0
		
		m.loText = loPageHeader.AddItem('Text')
		
		m.loForm = m.loGrid.Parent
		Do While TYPE("m.loForm.Caption") != "C" && loForm.BaseClass <> "Form" And Vartype(m.loForm.Parent)="O"
			m.loForm = m.loForm.Parent
		Enddo
		
		m.loText.cExpression = m.loForm.Caption
		m.loText.nVPosition  = 0.1
		m.loText.nHPosition  = 0.1
		m.loText.nFontSize   = 18
		m.loText.lFontBold   = .T.
		m.lnMaxBottom = 0
		
		SELECT(m.lcUniqueCursorName)
		Scan All
			m.lcAlign = "left"
			Do Case
			Case Alignment = 3
				If Type$"NYIFBDT"
					m.lcAlign = "right"
				Else
					m.lcAlign = "left"
				Endif
			Case Alignment = 0
				m.lcAlign = "left"
			Case Alignment = 1
				m.lcAlign = "center"
			Case Alignment = 2
				m.lcAlign = "right"
			Endcase
			m.loText = loPageHeader.AddItem('Text')
			m.loText.cExpression = Caption
			m.loText.nVPosition  = (Top/96) + 0.50
			m.loText.nHPosition  = (Left/96) + 0.125
			m.loText.nWidth      = (Width+2)/96
			m.loText.cFontName   = CaptionFontName
			m.loText.nFontSize   = CaptionFontSize
			m.loText.lFontBold   = Bitand(CaptionFontStyle,1)=1
			m.loText.lFontItalic = Bitand(CaptionFontStyle,2)=2
			m.loText.nForeColor  = CaptionForeColor
			m.loText.cAlignment  = m.lcAlign
		
			m.lnMaxBottom = (Top/96) + 0.50 + (Height/96)
		
			m.loField = loDetail.AddItem('Field')
			m.loField.cExpression = Expr
			m.loField.nWidth      = (Width+2)/96
			m.loField.nVPosition  = (Top/96) + 0.125
			m.loField.nHPosition  = (Left-1)/96 + 0.125
			m.loField.cFontName   = FontName
			m.loField.nFontSize   = FontSize
			m.loField.lFontBold   = Bitand(FontStyle,1)=1
			m.loField.lFontItalic = Bitand(FontStyle,2)=2
			m.loField.nForeColor  = ForeColor
			m.loField.cAlignment  = m.lcAlign
			m.loField.cDataType   = Icase(Type$"NYIFB","N", Type$"DT", "D", "C")
			m.loField.cPicture    = InputMask
			m.loField.cDesignCaption = Caption
		Endscan
		
		m.loObject = loPageHeader.AddItem('Line')
		m.loObject.nWidth     = m.lnPageWidth/96
		m.loObject.nVPosition = m.lnMaxBottom
		m.loObject.nHPosition = 0
		m.loObject.nPenSize   = 1
		m.loObject.nForeColor = Rgb(0, 0, 128)
		IF FILE(m.tcFRXName)
			ERASE (m.tcFRXName)
		ENDIF
		m.loReport.Save()
		
		IF FILE(m.tcFRXName)
			TRY
				Select (m.loGrid.RecordSource)
				REPORT FORM (m.tcFRXName) TO PRINTER PROMPT PREVIEW
				IF FILE(m.tcFRXName)
					ERASE (m.tcFRXName)
				ENDIF
			CATCH
				*!* Handle the error however you wish here
			ENDTRY
		ENDIF
		
		Select(m.lnSelect)
		
	ENDPROC

	PROCEDURE createcombocursor		&& INTERNAL USE: Creates an internal cursor to hold the list items available in a column in the target grid.
		LPARAMETERS tcTempCursorName, toComboBox
		
		LOCAL lnCounter, lcControlSourceType, lnSelectWas
		m.lnSelectWas = SELECT()
		CREATE CURSOR (m.tcTempCursorName) (disptext V(99), fkid V(99))
		FOR m.lnCounter = 1 TO m.toComboBox.listcount
			IF this.casesensitive
				INSERT INTO (m.tcTempCursorName) ;
				VALUES (m.toComboBox.list(m.lnCounter,1), m.toComboBox.list(m.lnCounter, m.toComboBox.boundcolumn))
			ELSE
				INSERT INTO (m.tcTempCursorName) ;
				VALUES (UPPER(m.toComboBox.list(m.lnCounter,1)), m.toComboBox.list(m.lnCounter, m.toComboBox.boundcolumn))
			ENDIF
		ENDFOR
		m.lcControlSourceType = TYPE(m.toComboBox.controlsource)
		IF !INLIST(m.lcControlSourceType, "C", "M")
			IF m.lcControlSourceType = "N"
				m.lcControlSourceType = m.lcControlSourceType + "(16,4)"
			ENDIF
			ALTER table (m.tcTempCursorName) ALTER COLUMN fkid &lcControlSourceType
		ENDIF
		SELECT(m.tcTempCursorName)
		INDEX on fkid TAG fkid
		
		SELECT (m.lnSelectWas)
		
	ENDPROC

	PROCEDURE createscreenreference		&& INTERNAL USE: Creates a public reference to the _Screen. This is part of a workaround for a VFP bug where _Screen.A(1,1) will be normailzed as .A(1,1,_Screen) which causes Filter() to return an invalid filter string if _Screen were to be included.
		IF TYPE("_GEScr") = "U"
			PUBLIC _GEScr
		ENDIF
		IF VARTYPE(_GEScr) != "O"
			_GEScr = _Screen
		ENDIF
		
	ENDPROC

	PROCEDURE Destroy
		LOCAL lnSelectWas, lcCursorName
		TRY
			UNBINDEVENTS(THIS)
			IF VARTYPE(THIS.GridObject)="O"
				UNBINDEVENTS(THIS.GridObject)
			ENDIF
			REMOVEPROPERTY(_SCREEN, THIS.GlobalArrayName)
			USE IN SELECT(THIS.GlobalArrayName)
			UNBINDEVENTS(0)
			IF FILE(THIS.IndexFile)
				m.lnSelectWas = SELECT()
				SELECT (THIS.PARENTTABLE)
				SET INDEX TO
				ERASE (THIS.IndexFile)
				SELECT (m.lnSelectWas)
			ENDIF
			IF VARTYPE(THIS.combocursorcollection) = "O"
				FOR EACH m.lcCursorName IN THIS.combocursorcollection
					IF VARTYPE(m.lcCursorName) = "C" AND USED(m.lcCursorName)
						USE IN SELECT(m.lcCursorName)
					ENDIF
				NEXT
			ENDIF
			STORE NULL TO THIS.GridObject, THIS.CurrentColumn, THIS.ColumnObject, This.SearchAndFilterForm
			STORE NULL TO THIS.GridTemplatesImage, THIS.ComboCursorCollection, this.GridTemplatesForm, This.ColumnsForm
		CATCH
		ENDTRY
		
	ENDPROC

	PROCEDURE getcolumnobject		&& INTERNAL USE: Returns a reference to the column object the user's mouse is currently over.
		LOCAL ARRAY laObject(1,4)
		LOCAL loObject, lcBaseClass
		=AMOUSEOBJ(m.laObject)
		m.loObject = m.laObject(1,1)
		IF TYPE("m.loObject.baseclass") = "C"
			m.lcBaseClass = UPPER(m.loObject.baseclass)
			DO case
			CASE m.lcBaseClass = "COLUMN"
				*!* Do nothing as m.loObject is the column
			CASE m.lcBaseClass = "HEADER"
				m.loObject = m.loObject.Parent
			OTHERWISE
				m.loObject = NULL
			ENDCASE
		ELSE
			m.loObject = NULL
		ENDIF
		This.columnobject = m.loObject
		RETURN m.loObject
	ENDPROC

	PROCEDURE getcombocursorname		&& INTERNAL USE: Returns the name of the internal cursor representing the combobox sent in.
		LPARAMETERS toComboBox
		LOCAL lnKeyIndex, lcTempCursorName
		IF VARTYPE(this.combocursorcollection) != "O"
			This.combocursorcollection = CREATEOBJECT("collection")
		ENDIF
		m.lcTempCursorName = ""
		m.lnKeyIndex = This.combocursorcollection.getkey(m.toComboBox.parent.name)
		IF m.lnKeyIndex = 0
			m.lcTempCursorName = SYS(2015)
			This.combocursorcollection.add(m.lcTempCursorName, m.toComboBox.parent.name)
		ELSE
			m.lcTempCursorName = This.combocursorcollection.Item(m.lnKeyIndex)
		ENDIF
		IF !USED(m.lcTempCursorName) AND !EMPTY(m.lcTempCursorName)
			this.createcombocursor(m.lcTempCursorName, m.toComboBox)
		ENDIF
		This.currentcombocursorname = m.lcTempCursorName
		RETURN m.lcTempCursorName
	ENDPROC

	PROCEDURE getheaderobject		&& INTERNAL USE: Returns a reference to the header object for the column that the user's mouse is currently over.
		LOCAL loObject
		m.loObject = this.GetColumnObject()
		IF !ISNULL(m.loObject) AND TYPE("m.loObject.baseclass") = "C" AND UPPER(m.loObject.baseclass) = "COLUMN"
			*<m.loObject = m.loObject.Controls(1) && Get header control
		   m.loObject = m.loObject.Header1 && Get header control
		ENDIF
		RETURN m.loObject
	ENDPROC

	PROCEDURE getmydocumentspath
		#DEFINE CSIDL_PERSONAL 0x0005
		LOCAL lcFolderPath, lcDocumentsPath
		m.lcFolderPath = space(255)
		
		DECLARE SHORT SHGetFolderPath IN SHFolder.dll ; 
		    INTEGER hwndOwner, INTEGER nFolder, INTEGER hToken, ; 
		    INTEGER dwFlags, STRING @pszPath 
		
		SHGetFolderPath(0, CSIDL_PERSONAL, 0, 0, @m.lcFolderPath)
		
		m.lcDocumentsPath = Alltrim(m.lcFolderPath)
		
		m.lcDocumentsPath = SubStr(m.lcDocumentsPath,1, Len(m.lcDocumentsPath) - 1)
		RETURN ADDBS(m.lcDocumentsPath)
	ENDPROC

	PROCEDURE getsortexpression		&& INTERNAL USE: Returns the sort expression to be used for indexing/sorting a column within the target grid.
		LPARAMETERS tcFieldName, tlIsCombobox
		LOCAL lcType, lcSortExpression
		m.lcType = TYPE(m.tcFieldName)
		IF PCOUNT() < 2
			m.tlIsCombobox = .F.
		ENDIF
		IF m.tlIsCombobox
			m.lcSortExpression = this.currentcombocursorname + [.disptext FOR SEEK(&tcFieldName, "] + this.currentcombocursorname + [","fkid")]
		ELSE
			DO CASE
				CASE m.lcType $ "CM"
					m.lcSortExpression = [UPPER(LEFT(NVL(] + m.tcFieldName + [,""), 99))]
				CASE lcType = "N"
					m.lcSortExpression = [NVL(]  + m.tcFieldName + [, 0)]
				CASE m.lcType $ "D"
					m.lcSortExpression = [NVL(] + m.tcFieldName + [, {})]
				CASE m.lcType $ "T"
					m.lcSortExpression = [NVL(] + m.tcFieldName + [, {/:})]
				CASE m.lcType == "L"
					m.lcSortExpression = [NVL(]  + m.tcFieldName + [, .F.)]
				CASE m.lcType == "Y"
					m.lcSortExpression = [NVL(]  + m.tcFieldName + [, $0.00)]
				OTHERWISE
					m.lcSortExpression = ""
			ENDCASE
		ENDIF
		
		RETURN m.lcSortExpression
	ENDPROC

	PROCEDURE getuserapplicationdatapath		&& INTERNAL USE: Returns the parth to the User's Application Data directory (profile specific AppData on Vista).
		#Define CSIDL_APPDATA 0x001a
		
		Local m.lcSpecialFolderPath, m.lcApplicationDataPath
		m.lcSpecialFolderPath = Space(255)
		
		Declare SHGetSpecialFolderPath In SHELL32.Dll ;
			LONG hwndOwner, ;
			STRING @cSpecialFolderPath, ;
			LONG nWhichFolder
		
		SHGetSpecialFolderPath(0, @m.lcSpecialFolderPath, CSIDL_APPDATA)
		m.lcApplicationDataPath = Alltrim(m.lcSpecialFolderPath)
		m.lcApplicationDataPath = Substr(m.lcApplicationDataPath,1, Len(m.lcApplicationDataPath)-1)
		m.lcApplicationDataPath = Addbs(m.lcApplicationDataPath) + This.CompanyName
		If !Directory(m.lcApplicationDataPath)
			Mkdir (m.lcApplicationDataPath)
		Endif
		m.lcApplicationDataPath = Addbs(m.lcApplicationDataPath) + This.ProductName
		If !Directory(m.lcApplicationDataPath)
			Mkdir (m.lcApplicationDataPath)
		Endif
		Return Addbs(m.lcApplicationDataPath)
	ENDPROC

	PROCEDURE gridmouseup		&& INTERNAL USE: Fires when the target grid's MouseUp event occurs.
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		LOCAL lnLocationOut
		m.lnLocationOut = 0
		This.GridObject.GridHitTest(MCOL(0, 3), MROW(0, 3), @lnLocationOut)
		IF m.lnLocationOut = 5 && Split bar was probably moved, so we need to save partition
			This.savegridpreferences(this.GridObject)
		ENDIF
		
	ENDPROC

	PROCEDURE headerclick		&& INTERNAL USE: Fires when the target column header's Click event occurs.
		LOCAL loObject, lnLeft, lnTop, loActiveControlInColumn, lcColumnCursorName, llIsCombobox, lcTag, llUseHeaderFilterImage, lcHeaderImage  
		this.currentcombocursorname = ""
		STORE .F. TO m.llIsCombobox, ;
		             m.llUseHeaderFilterImage
		IF this.allowgridsort AND !this.columnwasmoved
			m.loObject = This.GetHeaderObject()
			IF !ISNULL(m.loObject)
			    m.lcTag = m.loObject.Tag
			    This.ClearHeaderSortImages()
				m.lcHeaderImage  = UPPER(JUSTFNAME(m.loObject.picture))
		        IF !EMPTY(m.lcHeaderImage) AND INLIST(lcHeaderImage,UPPER(This.HeaderFilterImage),UPPER(This.HeaderFilterDescendingImage),UPPER(This.HeaderFilterAscendingImage))	    
		          m.llUseHeaderFilterImage = .T.
		        ENDIF
			    DO CASE
			      CASE m.lcTag = 'D'
			          m.loObject.Tag     = 'N'
			          IF m.llUseHeaderFilterImage
			            m.loObject.Picture = This.HeaderFilterImage            && Show Filter Image
			          ELSE
			            m.loObject.Picture = ''                                && Change to No Sort Order from Descending 
			          ENDIF 
		
			      CASE m.lcTag = 'A'
			          m.loObject.Tag     = 'D'
			          IF m.llUseHeaderFilterImage
			            m.loObject.Picture = This.HeaderFilterDescendingImage && Show Filter Descending Image
			          ELSE 
			            m.loObject.Picture = This.HeaderDescendingImage       && Change to Descending from Ascending	          
			          ENDIF 
			          
			      OTHERWISE
			          m.loObject.Tag     = 'A'
			          IF m.llUseHeaderFilterImage
			            m.loObject.Picture = This.HeaderFilterAscendingImage  && Show Filter Ascending Image
			          ELSE 
		  	            m.loObject.Picture = This.HeaderAscendingImage        && Change to Ascending from No Sort Order
			          ENDIF 
		          
			    ENDCASE 
				m.loActiveControlInColumn = EVALUATE("m.loObject.parent." + m.loObject.parent.currentcontrol)
				IF LOWER(ALLTRIM(m.loActiveControlInColumn.Baseclass)) = "combobox"
					m.lcColumnCursorName = this.getcombocursorname(m.loActiveControlInColumn)
					m.llIsCombobox = .T.
				ENDIF
				this.applysort(m.llIsCombobox,,m.loObject.Tag)
				this.SetHeaderImages()
			ENDIF
		ELSE
			this.columnwasmoved = .F.
		ENDIF
		
	ENDPROC

	PROCEDURE headerrightclick		&& INTERNAL USE: Fires when the target column header's Rightclick event occurs.
		LOCAL loHeaderObject, lnLeft, lnTop, lnLocationOut, lcMenuCommand
		LOCAL lnColumnCounter, lnColumnOrderCounter, loColumn, lnCurrentMenuItem, lcPublicGridExtraReference, lnCountMax
		this.currentcombocursorname = ""
		m.lnLocationOut = 0
		This.GridObject.GridHitTest(MCOL(0, 3), MROW(0, 3), @lnLocationOut)
		IF m.lnLocationOut = 1
			m.loHeaderObject = This.GetHeaderObject()
			IF !ISNULL(m.loHeaderObject)
				IF this.Allowcolumnvisibility OR This.AllowGridExport
					m.lcPublicGridExtraReference = SYS(2015)
					PUBLIC &lcPublicGridExtraReference
					&lcPublicGridExtraReference = This
					m.lnCurrentMenuItem = 1
					DEFINE POPUP mnuContext SHORTCUT RELATIVE FROM MROW(),MCOL()
					IF This.AllowGridFilter
						DEFINE BAR (m.lnCurrentMenuItem) OF mnuContext PROMPT "Search/Filter" PICTURE "search16.bmp"
					ELSE
						DEFINE BAR (m.lnCurrentMenuItem) OF mnuContext PROMPT "Search" PICTURE "search16.bmp"
					ENDIF
					m.lcMenuCommand = m.lcPublicGridExtraReference + ".ShowSearchFilterForm(" + m.lcPublicGridExtraReference + ".GridObject." + m.loHeaderObject.Parent.Name + "." + m.loHeaderObject.Name + ")"
					ON SELECTION BAR (m.lnCurrentMenuItem) OF mnuContext &lcMenuCommand
					IF This.AllowGridExport
						m.lnCurrentMenuItem = m.lnCurrentMenuItem + 1
						DEFINE BAR (m.lnCurrentMenuItem) OF mnuContext PROMPT "Excel Export" PICTURE "excel.jpg"
						m.lcMenuCommand = m.lcPublicGridExtraReference + ".CopyToExcel()"
						ON SELECTION BAR (m.lnCurrentMenuItem) OF mnuContext &lcMenuCommand
					ENDIF
					IF This.AllowGridReport
						m.lnCurrentMenuItem = m.lnCurrentMenuItem + 1
						DEFINE BAR (m.lnCurrentMenuItem) OF mnuContext PROMPT "Print Preview" PICTURE "printer16.bmp"
						m.lcMenuCommand = m.lcPublicGridExtraReference + ".CopyToReport()"
						ON SELECTION BAR (m.lnCurrentMenuItem) OF mnuContext &lcMenuCommand
					ENDIF
					IF this.Allowcolumnvisibility
						m.lnCurrentMenuItem = m.lnCurrentMenuItem + 1
						DEFINE BAR (m.lnCurrentMenuItem) OF mnuContext PROMPT "\-"
						m.lnCountMax = MIN(This.GridObject.ColumnCount, This.MaxColumnsInContextMenu)
						FOR m.lnColumnCounter = 1 TO m.lnCountMax
							FOR m.lnColumnOrderCounter = 1 TO This.GridObject.ColumnCount
								m.loColumn = This.GridObject.Columns(m.lnColumnOrderCounter)
								IF m.loColumn.ColumnOrder != m.lnColumnCounter
									LOOP
								ELSE
									m.lnCurrentMenuItem = m.lnCurrentMenuItem + 1
									DEFINE BAR (m.lnCurrentMenuItem) OF mnuContext PROMPT m.loColumn.controls(1).caption
									SET MARK OF BAR (m.lnCurrentMenuItem) OF mnuContext TO m.loColumn.Visible
									m.lcMenuCommand = m.lcPublicGridExtraReference + ".ShowHideColumn(" + m.lcPublicGridExtraReference + ".GridObject." + m.loColumn.Name + ")"
									ON SELECTION BAR (m.lnCurrentMenuItem) OF mnuContext &lcMenuCommand
								ENDIF
							ENDFOR
						ENDFOR
						IF This.GridObject.ColumnCount > This.MaxColumnsInContextMenu
							IF This.MaxColumnsInContextMenu != 0
								m.lnCurrentMenuItem = m.lnCurrentMenuItem + 1
								DEFINE BAR (m.lnCurrentMenuItem) OF mnuContext PROMPT "\-"
							ENDIF
							m.lnCurrentMenuItem = m.lnCurrentMenuItem + 1
							DEFINE BAR (m.lnCurrentMenuItem) OF mnuContext PROMPT "More..."
							m.lcMenuCommand = m.lcPublicGridExtraReference + ".ShowColumnsForm()"
							ON SELECTION BAR (m.lnCurrentMenuItem) OF mnuContext &lcMenuCommand
						ENDIF
					ENDIF
					ACTIVATE POPUP mnuContext BAR 1
					RELEASE &lcPublicGridExtraReference
				ELSE
					this.ShowSearchFilterForm(m.loHeaderObject)
				ENDIF
			ENDIF
		ELSE
			This.savegridpreferences(this.GridObject)
		ENDIF
	ENDPROC

	PROCEDURE Init
		This.GlobalArrayName = SYS(2015)
		ADDPROPERTY(_screen, this.GlobalArrayName+"[1,1]",.F.)
		THIS.indexfile = ADDBS(SYS(2023)) + This.GlobalArrayName + ".IDX"
		This.CheckTemplateTable()
		
	ENDPROC

	PROCEDURE positionform		&& INTERNAL USE: Used to properly position the Search/Filter form by the target column's header control.
		LPARAMETERS toSearchAndFilterForm, toHeader
		LOCAL lnTop
		IF TYPE("m.toSearchAndFilterForm.name") = "C" AND TYPE("m.toHeader.caption") = "C"
			WITH m.toSearchAndFilterForm
				m.lnTop = OBJTOCLIENT(m.toHeader, 1 ) + IIF(THISFORM.TITLEBAR=1,SYSMETRIC(9),0) + m.toHeader.PARENT.PARENT.HEADERHEIGHT + ;
					IIF(THISFORM.BORDERSTYLE = 3, SYSMETRIC(4), SYSMETRIC(13)) + ;
					IIF(THISFORM.SHOWWINDOW = 2, Thisform.Top, OBJTOCLIENT(THISFORM, 1 )) + 1 && thanks to Vassilis Aggelakos for the Titlebar=1 fix/idea
				.LEFT = OBJTOCLIENT(m.toHeader, 2) + IIF(THISFORM.BORDERSTYLE = 3, SYSMETRIC(3), ;
					SYSMETRIC(12)) + IIF(THISFORM.SHOWWINDOW = 2, Thisform.Left, OBJTOCLIENT( THISFORM, 2 ))
				IF ((m.lnTop + .HEIGHT) > SYSMETRIC(2))
					m.lnTop = m.lnTop - .HEIGHT - m.toHeader.PARENT.PARENT.HEADERHEIGHT - (2 * SYSMETRIC(13)) + 4
				ENDIF
				.TOP = m.lnTop - 1
			ENDWITH
		ENDIF
		
	ENDPROC

	PROCEDURE restorecolumnfilters		&& INTERNAL USE: Used to restore the column filters that were saved as a template by the user.
		LPARAMETERS tnTemplatePkID
		LOCAL lnSelectWas, lnCounter, lcGlobalArrayNameWas, lcGlobalArrayNameIs, lcGlobalArray
		LOCAL ARRAY _GEAColumn(1)
		LOCAL ARRAY _GEAGlobal(1)
		m.lnSelectWas   = SELECT()
		m.lcGlobalArray = [_GEScr.] + this.GlobalArrayName
		IF This.TemplateLocate(m.tnTemplatePkID)
			RESTORE From Memo FilterCol ADDITIVE
			RESTORE From Memo FilterGlob ADDITIVE
			m.lcGlobalArrayNameWas = ALLTRIM(globala)
			m.lcGlobalArrayNameIs = this.globalarrayname
			FOR m.lnCounter = 1 TO ALEN(_GEAColumn, 1)
				IF TYPE("_GEAColumn(m.lnCounter, 1)") = "C"
					_GEAColumn(m.lnCounter, 1) = STRTRAN(_GEAColumn(m.lnCounter, 1), m.lcGlobalArrayNameWas, m.lcGlobalArrayNameIs, -1, -1, 1)
				ENDIF
			ENDFOR
			this.clearfilter()
			IF (ALEN(_GEAGlobal,1) > 0 AND ALEN(_GEAGlobal,2) > 0)
				DIMENSION &lcGlobalArray(ALEN(_GEAGlobal,1), ALEN(_GEAGlobal,2))
				=ACOPY(_GEAGlobal, &lcGlobalArray)
				IF (ALEN(_GEAColumn,1) > 0 AND ALEN(_GEAColumn,2) > 0)
					DIMENSION this.acolumnfilters(ALEN(_GEAColumn,1), ALEN(_GEAColumn,2))
					=ACOPY(_GEAColumn, this.acolumnfilters)
				ENDIF
			ELSE
				DIMENSION this.acolumnfilters(1, 3)
				STORE .F. TO this.acolumnfilters
			ENDIF
		ENDIF
		SELECT (m.lnSelectWas)
	ENDPROC

	PROCEDURE restorecolumnsort		&& INTERNAL USE: Used to restore thecolumn sort that were saved as a template by the user.
		LPARAMETERS tnTemplatePkID, tcSortAscending
		LOCAL lnSelectWas, loColumnObject
		m.lnSelectWas = SELECT()
		IF This.TemplateLocate(m.tnTemplatePkID) AND !EMPTY(colname)
			This.currentcolumn = EVALUATE("this.GridObject." + ALLTRIM(colname))
			m.tcSortAscending = SortAsc
		ENDIF
		SELECT (m.lnSelectWas)
		
	ENDPROC

	PROCEDURE restorecustomcolumnfilters		&& INTERNAL USE: Used to restore the custom column filters that were saved as a template by the user.
		LPARAMETERS tnTemplatePkID
		LOCAL lnSelectWas
		LOCAL ARRAY _GEACustom(1)
		m.lnSelectWas = SELECT()
		IF This.TemplateLocate(m.tnTemplatePkID)
			RESTORE From Memo FilterCusT ADDITIVE
			IF (ALEN(_GEACustom,1) > 0 AND ALEN(_GEACustom,2) > 0)
				DIMENSION this.customcolumnfilters(ALEN(_GEACustom,1),ALEN(_GEACustom,2))
				=ACOPY(_GEACustom, this.customcolumnfilters)
			ENDIF
		ENDIF
		SELECT (m.lnSelectWas)
		
	ENDPROC

	PROCEDURE restoregridpreferences		&& INTERNAL USE: Used to restore the user's preferences that were saved using the SaveGridPreferences method.
		LPARAMETERS toGridObject
		Local lcGridHierarchy, lcString, lcPrefs, lcPrefFileContents, lcBeginPrefs, lcEndPrefs, lcPrefFile, ;
			loColumn, lnCounter, lnMax, loExc as Exception, lnAdditionalProperties
		IF this.allowgridpreferences
			m.lcPrefFile = This.GetUserApplicationDataPath() + This.GridPreferenceFile
			m.lcPrefFileContents = ""
			If File(m.lcPrefFile)
				Try
					m.lcPrefFileContents = Filetostr(m.lcPrefFile)
					m.lcGridHierarchy = Sys(1272, m.toGridObject)
					m.lcBeginPrefs = m.lcGridHierarchy + "("
					m.lcEndPrefs = ")"
					m.lcPrefs = Strextract(m.lcPrefFileContents,m.lcBeginPrefs,m.lcEndPrefs,1,1)
					If !Empty(m.lcPrefs)
						m.lnAdditionalProperties = (OCCURS("::", m.lcPrefs) - 1)
						IF m.lnAdditionalProperties > 0
							=Alines(laPrefs, m.lcPrefs, 7, ",", "::")
							m.lnMax =  Min(m.toGridObject.ColumnCount * 2, Alen(laPrefs) - m.lnAdditionalProperties)
						ELSE
							=Alines(laPrefs, m.lcPrefs, 7, ",")
							m.lnMax =  Min(m.toGridObject.ColumnCount * 2, Alen(laPrefs))					
						ENDIF
						For m.lnCounter = 1 To m.lnMax - 3 Step 2
							m.loColumn = m.toGridObject.Columns((m.lnCounter + 1)/2)
							If Type("m.loColumn.columnorder") = "N"
								m.loColumn.ColumnOrder = Val(laPrefs(m.lnCounter))
								m.loColumn.Width = Val(laPrefs(m.lnCounter + 1))
							Endif
						ENDFOR
						IF m.lnAdditionalProperties > 0
							m.toGridObject.LockColumns = Val(laPrefs(m.lnCounter + 2))
						ENDIF
						IF m.lnAdditionalProperties > 1
							m.toGridObject.LockColumnsLeft = Val(laPrefs(m.lnCounter + 3))
						ENDIF
						IF m.lnAdditionalProperties > 2
							m.toGridObject.Partition = Val(laPrefs(m.lnCounter + 4))
						ENDIF
					Endif
				CATCH TO m.loExc && Just let any errors fail silently
				Endtry
			ENDIF
		ENDIF
	ENDPROC

	PROCEDURE saveacolumnfilters		&& INTERNAL USE: Used to save column filters.
		LPARAMETERS tnTemplatePkID
		LOCAL lnSelectWas, lcGlobalArray
		LOCAL ARRAY _GEAColumn(1)
		LOCAL ARRAY _GEAGlobal(1)
		m.lnSelectWas = SELECT()
		m.lcGlobalArray = [_GEScr.] + this.GlobalArrayName
		IF This.TemplateLocate(m.tnTemplatePkID)
			=ACOPY(this.acolumnfilters, _GEAColumn)
			SAVE to Memo FilterCol ALL LIKE _GEAColumn
			=ACOPY(&lcGlobalArray, _GEAGlobal)
			SAVE to Memo FilterGlob ALL LIKE _GEAGlobal
			replace globala WITH this.globalarrayname
		ENDIF
		SELECT (m.lnSelectWas)
		
	ENDPROC

	PROCEDURE savecolumnsort		&& INTERNAL USE: Used to save the column sort.
		LPARAMETERS tnTemplatePkID
		LOCAL lnSelectWas
		m.lnSelectWas = SELECT()
		IF TYPE("this.currentcolumn.name") = "C" AND TYPE("this.currentcolumn.header1.name") = "C" AND This.TemplateLocate(m.tnTemplatePkID)
			replace colname WITH this.currentcolumn.name, sortasc WITH This.CurrentColumn.Header1.Tag
		ENDIF
		SELECT (m.lnSelectWas)
		
	ENDPROC

	PROCEDURE savecustomcolumnfilters		&& INTERNAL USE: Used to save the custom column filters.
		LPARAMETERS tnTemplatePkID
		LOCAL lnSelectWas
		LOCAL ARRAY _GEACustom(1)
		m.lnSelectWas = SELECT()
		IF This.TemplateLocate(m.tnTemplatePkID)
			=ACOPY(this.customcolumnfilters, _GEACustom)
			SAVE to Memo FilterCust ALL LIKE _GEACustom
		ENDIF
		SELECT (m.lnSelectWas)
		
	ENDPROC

	PROCEDURE savegridpreferences		&& INTERNAL USE: Used to save the user's preferences (columns widths, column order, partition setting, and lockcolumns)
		LPARAMETERS toGridObject
		Local lcGridHierarchy, lcString, lcPrefs, lcPrefFileContents, ;
			lcBeginPrefs, lcEndPrefs, lcPrefFile, loColumn, lnCounter, loExc as Exception
		IF this.allowgridpreferences
			m.lcGridHierarchy = Sys(1272, m.toGridObject)
			m.lcBeginPrefs = m.lcGridHierarchy + "("
			m.lcEndPrefs = ")"
			m.lcPrefFile = This.GetUserApplicationDataPath() + This.GridPreferenceFile
			m.lcPrefFileContents = ""
			If File(m.lcPrefFile)
				m.lcPrefFileContents = Filetostr(m.lcPrefFile)
			Endif
			m.lcPrefs = Strextract(m.lcPrefFileContents,m.lcBeginPrefs,m.lcEndPrefs,1,5)
			m.lcString = ""
			Try
				For m.lnCounter = 1 To m.toGridObject.ColumnCount
					m.loColumn = m.toGridObject.Columns(m.lnCounter)
					m.lcString = m.lcString + Transform(m.loColumn.ColumnOrder) + ","
					m.lcString = m.lcString + Transform(m.loColumn.Width) + ","
				ENDFOR
				m.lcString = m.lcString + "::" + TRANSFORM(m.toGridObject.LockColumns)
				m.lcString = m.lcString + "::" + TRANSFORM(m.toGridObject.LockColumnsLeft)
				m.lcString = m.lcString + "::" + TRANSFORM(m.toGridObject.Partition) + 	"::"
			CATCH TO m.loExc
			ENDTRY
			If !Empty(m.lcString)
				m.lcString = m.lcBeginPrefs + m.lcString + m.lcEndPrefs
				If Empty(m.lcPrefs) Or m.lcString != m.lcPrefs
					If Empty(m.lcPrefs)
						m.lcPrefFileContents = m.lcPrefFileContents + m.lcString + Chr(13) + Chr(10)
					Else
						m.lcPrefFileContents = Strtran(m.lcPrefFileContents, m.lcPrefs, m.lcString, 1, 1, 1)
					Endif
					Set Safety Off
					=Strtofile(m.lcPrefFileContents, m.lcPrefFile, 0)
				Endif
			ENDIF
		ENDIF
	ENDPROC

	PROCEDURE search		&& INTERNAL USE: Used to help provide the incremental search feature.
		LPARAMETERS tcSearchPhrase, tlFindNext, lcSearchCommand
		LOCAL lcRecordSource, lnSelectWas, lcControlSource, lcSearchValue, lnRecnoWas
		LOCAL llLockScreenWas, loActiveControlInColumn, lcCurrentComboCursorName
		LOCAL ARRAY aTemp(1)
		aTemp(1) = Null
		m.lcRecordSource = This.GridObject.recordsource
		If Used(m.lcRecordSource) AND TYPE("This.ColumnObject.Name") = "C"
		    m.lnSelectWas = SELECT()
			m.lcControlSource = This.ColumnObject.ControlSource	
			m.loActiveControlInColumn = EVALUATE("This.ColumnObject." + This.ColumnObject.CurrentControl)
			IF LOWER(m.loActiveControlInColumn.BaseClass) = "combobox" and m.loActiveControlInColumn.BoundColumn != 1
				If This.casesensitive
					m.lcSearchCommand = [At(] && m.lcSearchValue, Transform(&lcControlSource)) > 0]
				ELSE
					m.lcSearchCommand = [Atc(]
				ENDIF
				m.lcSearchCommand = m.lcSearchCommand + [Alltrim(Transform(m.tcSearchPhrase)), disptext)>0]
				m.lcCurrentComboCursorName = this.currentcombocursorname
				SELECT fkid FROM (m.lcCurrentComboCursorName) WHERE &lcSearchCommand INTO ARRAY aTemp
				IF ISNULL(aTemp(1)) OR _tally < 1
					m.lcSearchCommand = [.F.]
				ELSE
					IF _tally > 1
						m.lcSearchCommand = [Ascan(aTemp, &lcControlSource)>0]
					ELSE
						m.lcSearchCommand = [&lcControlSource = aTemp(1)]
					ENDIF
				ENDIF
			ELSE
				m.lcSearchValue = Alltrim(Transform(m.tcSearchPhrase))
				If This.casesensitive
					m.lcSearchCommand = [At(] && m.lcSearchValue, Transform(&lcControlSource)) > 0]
				ELSE
					m.lcSearchCommand = [Atc(]
				ENDIF
				m.lcSearchCommand = m.lcSearchCommand + [m.lcSearchValue,Transform(&lcControlSource))>0]
			ENDIF
			
			Select (m.lcRecordSource)
			m.lnRecnoWas = RECNO()
			If m.tlFindNext
				If !Eof(m.lcRecordSource)
					Skip 1 In (m.lcRecordSource)
				ELSE
					GO TOP IN (m.lcRecordSource)
				ENDIF
			ELSE
				GO TOP IN (m.lcRecordSource)
			ENDIF
			Locate Rest For &lcSearchCommand
			If !Found()
				TRY
					GO RECORD (m.lnRecnoWas) IN (m.lcRecordSource)
				CATCH
					Go Top In (m.lcRecordSource)
				ENDTRY
				IF m.tlFindNext
					IF MESSAGEBOX("Search has reached the last record without finding another match. Do you want to continue searching from the first record?",36,"Continue Searching from the Beginning?") = 6
						Go Top In (m.lcRecordSource)
						Locate Rest For &lcSearchCommand
						IF !FOUND()
							MESSAGEBOX("A matching record could not be found.",64,"Unable to Locate Search Phrase")
							TRY
								GO RECORD (m.lnRecnoWas) IN (m.lcRecordSource)
							CATCH
								Go Top In (m.lcRecordSource)
							ENDTRY
						ENDIF
					ENDIF
				ELSE
					MESSAGEBOX("A matching record could not be found.",64,"Unable to Locate Search Phrase")
				ENDIF
			ENDIF
			*!* work around to allow highlighting/row update to show correctly in grid being searched as record pointer is moved
			m.llLockScreenWas = thisform.lockscreen
			thisform.lockscreen = .T.
			this.GridObject.setfocus()
			this.GridObject.refresh()
			this.SearchAndFilterForm.cmdSearch.setfocus()
			thisform.lockscreen = m.llLockScreenWas
			SELECT (m.lnSelectWas)
		Endif
		
		
	ENDPROC

	PROCEDURE setheaderimages		&& INTERNAL USE: Used to set the proper header pictures for the target grid.
		LOCAL loColumnObject, loHeaderObject, lcHeaderImage, llCustomFilterEnforced, lnCustomFilterIndex
		FOR EACH m.loColumnObject IN This.GridObject.Columns FOXOBJECT 
			m.llCustomFilterEnforced = .F.
		   *< m.loHeaderObject = m.loColumnObject.Controls(1)
		   m.loHeaderObject = m.loColumnObject.Header1
		   m.lcHeaderImage = UPPER(JUSTFNAME(m.loHeaderObject.picture))
			m.lnCustomFilterIndex = ASCAN(this.customcolumnfilters,ALLTRIM(m.loColumnObject.Name),-1,-1,1,15)
			IF m.lnCustomFilterIndex > 0 AND !EMPTY(this.customcolumnfilters(m.lnCustomFilterIndex,5))
				m.llCustomFilterEnforced = .T.
			ENDIF
			IF m.llCustomFilterEnforced OR ASCAN(this.acolumnfilters,ALLTRIM(m.loColumnObject.name),-1,-1,2,15) > 0
			  DO CASE  
			    CASE m.loHeaderObject.Tag = 'A'
			        m.loHeaderObject.picture = This.HeaderFilterAscendingImage   && Filtered Ascending Image
			        
			    CASE m.loHeaderObject.Tag = 'D'
			        m.loHeaderObject.picture = This.HeaderFilterDescendingImage  && Filtered Descending Image	    
			        
			    OTHERWISE     
					m.loHeaderObject.picture = This.HeaderFilterImage            && Filtered Only Image
			  ENDCASE   
			ELSE
			  IF !EMPTY(m.lcHeaderImage) ;
			  AND !INLIST(m.lcHeaderImage, UPPER(this.HeaderAscendingImage), UPPER(This.HeaderDescendingImage), UPPER(This.HeaderNoSortImage), ; 
			                               UPPER(this.HeaderFilterAscendingImage), UPPER(This.HeaderFilterDescendingImage))
				  STORE '' TO  m.loHeaderObject.picture, ;
				               m.loHeaderObject.Tag
			  ENDIF
			ENDIF
		ENDFOR
		
	ENDPROC

	PROCEDURE setheadertag		&& INTERNAL USE: Used to set the header tag based on the order that the table comes in on.
		LPARAMETERS toColumnObject, toColumnHeader, tlTryAgain
		LOCAL lcParentTable, lcParentOrder, lcControlSource, lcParentField, loActiveControlInColumn, lnSelectWas
		
		m.lcParentTable = UPPER(toColumnObject.Parent.RecordSource)
		m.lcParentOrder = ORDER(m.lcParentTable)
		m.tlTryAgain    = .F.
		
		IF EMPTY(m.lcParentOrder)
		  RETURN 
		ENDIF   
		
		lnSelectWas       = SELECT()
		m.lcControlSource = UPPER(toColumnObject.ControlSource)
		m.lcParentField   = JUSTEXT(m.lcControlSource)
		m.tlTryAgain      = .T.
		
		IF m.lcParentTable != JUSTSTEM(m.lcControlSource) ;
		OR TAGNO(m.lcParentOrder) != TAGNO(m.lcParentField)
		  RETURN 
		ENDIF
		
		m.loActiveControlInColumn = EVALUATE('m.toColumnObject.'+m.toColumnObject.CurrentControl)
		IF LOWER(ALLTRIM(m.loActiveControlInColumn.BaseClass)) = "combobox"
		  RETURN 
		ENDIF
		
		m.tlTryAgain = .F.
		This.CurrentColumn = toColumnObject
		
		SELECT(m.lcParentTable)
		IF DESCENDING()
		  m.toColumnHeader.Tag     = 'D'
		  m.toColumnHeader.Picture = This.HeaderDescendingImage && Show Descending Image
		ELSE
		  m.toColumnHeader.Tag     = 'A'
		  m.toColumnHeader.Picture = This.HeaderAscendingImage && Show Ascending Image  
		ENDIF 
		
		SELECT (lnSelectWas)
		
		RETURN 
	ENDPROC

	PROCEDURE setup		&& Call this when your target grid is ready for action (has a recordsource, columns, controlsources set, etc.).
		LOCAL loGridObject, loColumnObject, loHeaderObject, lcClassLib, lcGlobalArray, lcGridTemplatesImageName, lnGridExportAnchorValue, ;
		      llSetHeaderTag
		STORE Null TO This.GridObject, m.loColumnObject, m.loHeaderObject
		UNBINDEVENTS(this)
		this.CreateScreenReference()
		m.llSetHeaderTag = .T.
		m.lcGlobalArray  = [_GEScr.] + this.GlobalArrayName
		DIMENSION &lcGlobalArray.(1,1)
		STORE .F. TO &lcGlobalArray
		m.lcClassLib = LOWER(JUSTFNAME(this.ClassLibrary))
		IF OCCURS(JUSTSTEM(m.lcClassLib),LOWER(SET("Classlib"))) = 0
			IF FILE(this.ClassLibrary)
				SET CLASSLIB TO (this.ClassLibrary) ADDITIVE
			ELSE
				SET CLASSLIB TO (LOCFILE(m.lcClassLib)) ADDITIVE
			ENDIF
		ENDIF
		This.GridObject = EVALUATE(this.gridexpression)
		IF TYPE("This.GridObject.Name") = "C"
			this.restoregridpreferences(This.GridObject)
			This.BindGridEvents(This.GridObject)
			FOR EACH m.loColumnObject IN This.GridObject.Columns
				This.BindColumnEvents(m.loColumnObject)
				This.BindHeaderEvents(m.loColumnObject.Controls(1))
				IF m.llSetHeaderTag
				  This.SetHeaderTag(m.loColumnObject,m.loColumnObject.Controls(1),@m.llSetHeaderTag)
				ENDIF   
			ENDFOR
		    This.SetHeaderImages()
			this.originalfilter = FILTER(this.GridObject.recordsource)
			this.originalfilter = IIF(!EMPTY(this.originalfilter), "(" + this.originalfilter + ")", "")
			IF this.allowgridtemplates
				m.lcGridTemplatesImageName = SYS(2015)
				This.GridObject.parent.AddObject(m.lcGridTemplatesImageName,"GridExtraTemplates",this)
				this.GridTemplatesImage = EVALUATE("This.GridObject.parent." + m.lcGridTemplatesImageName)
				this.GridTemplatesImage.GridObject = this.GridObject
				BINDEVENT(this.GridObject, "zorder", this.GridTemplatesImage, "zorderupdate", 1)
				BINDEVENT(this.GridObject, "resize", this.GridTemplatesImage, "resizeupdate", 1)
				IF TYPE("this.GridTemplatesImage.Name") = "C"
					m.lnGridExportAnchorValue = 0
					IF BITTEST(This.GridObject.anchor,3)
						 m.lnGridExportAnchorValue = BITSET(m.lnGridExportAnchorValue, 3)
					ELSE
						IF BITTEST(This.GridObject.anchor,7)
							 m.lnGridExportAnchorValue = BITSET(m.lnGridExportAnchorValue, 7)
						ENDIF
					ENDIF
		
					IF BITTEST(This.GridObject.anchor,2)
						 m.lnGridExportAnchorValue = BITSET(m.lnGridExportAnchorValue, 2)
					ELSE
						IF BITTEST(This.GridObject.anchor,6)
							 m.lnGridExportAnchorValue = BITSET(m.lnGridExportAnchorValue, 6)
						ENDIF
					ENDIF
					this.GridTemplatesImage.Anchor = 0
					this.GridTemplatesImage.Left = (This.GridObject.Left + This.GridObject.Width - 19)
					IF INLIST(This.GridObject.scrollbars,0,2)
						this.GridTemplatesImage.Top = (This.GridObject.Top + This.GridObject.Height + 1)
					ELSE
						this.GridTemplatesImage.Top = (This.GridObject.Top + This.GridObject.Height - 18)
					ENDIF
					this.GridTemplatesImage.Anchor = m.lnGridExportAnchorValue
					this.GridTemplatesImage.visible = .T.
				ENDIF
			ENDIF
		ENDIF
		
	ENDPROC

	PROCEDURE showcolumnsform		&& INTERNAL USE: Used to display the Columns form that is shown when the user clicks the context menu's "More..." item.
		IF thisform.ShowWindow = 2
			This.ColumnsForm = CREATEOBJECT("gridcolumnstoplevel", this.GridObject)
		ELSE
			This.ColumnsForm = CREATEOBJECT("gridcolumns", this.GridObject)
		ENDIF
		IF TYPE("This.ColumnsForm.Caption") = "C"
			This.ColumnsForm.Show(1)
		ENDIF
		
	ENDPROC

	PROCEDURE showhidecolumn
		LPARAMETERS toColumn
		
		LOCAL loColumn, llTargetColumnVisible, lnVisibleColumnsFound
		
		IF TYPE("m.toColumn.name") = "C"
			m.llTargetColumnVisible = m.toColumn.Visible
			IF m.llTargetColumnVisible && user is trying to make column invisible
				m.lnVisibleColumnsFound = 0
		*!* Check to ensure that the user isn't about to make all of the columns invisible
		*!* Doing so would essentially lock them out of being able to make any of the columns
		*!* visible again because they wouldn't be able to get to the right-click context menu again.
				FOR EACH loColumn IN This.GridObject.Columns
					IF m.loColumn.Visible
						m.lnVisibleColumnsFound = m.lnVisibleColumnsFound + 1
					ENDIF
					IF m.lnVisibleColumnsFound > 1 && User will still have at least one visible column
						m.toColumn.Visible = !m.toColumn.Visible
						EXIT
					ENDIF
				NEXT
			ELSE && user is trying to make column visible
				m.toColumn.Visible = !m.toColumn.Visible
			ENDIF
		ENDIF
		
	ENDPROC

	PROCEDURE showsearchfilterform		&& INTERNAL USE: Used to display the Search/Filter form that is shown when the user clicks the context menu's "Search/Filter" item.
		LPARAMETERS toHeaderObject
		
		IF thisform.ShowWindow = 2
			This.SearchAndFilterForm = CREATEOBJECT("GridSearchAndFilterTopLevel", m.toHeaderObject.parent, this)
		ELSE
			This.SearchAndFilterForm = CREATEOBJECT("GridSearchAndFilter", m.toHeaderObject.parent, this)
		ENDIF
		IF TYPE("This.SearchAndFilterForm.Caption") = "C"
			this.positionform(This.SearchAndFilterForm, m.toHeaderObject)
			This.SearchAndFilterForm.Show()
		ENDIF
		
	ENDPROC

	PROCEDURE showtemplatesform
		LOCAL lcReturnError
		
		m.lcReturnError = This.TemplateCreateTable()
		
		IF EMPTY(m.lcReturnError)
			IF thisform.ShowWindow = 2
				This.GridTemplatesForm = CREATEOBJECT("GridTemplatesTopLevel", thisform, this.GridObject, this)
			ELSE
				This.GridTemplatesForm = CREATEOBJECT("GridTemplates", thisform, this.GridObject, this)
			ENDIF
			IF TYPE("This.GridTemplatesForm.Caption") = "C"
				This.GridTemplatesForm.Show(1)
			ENDIF
		ENDIF
		
		RETURN (m.lcReturnError)
	ENDPROC

	PROCEDURE templateapply		&& INTERNAL USE: Used by the grid templates screen to apply a user selected template.
		LPARAMETERS tnTemplatePkID
		LOCAL lnSelectWas, loActiveControlInColumn, llIsCombobox, llLockScreenWas, loHeaderObject, lcAscendingSort, llUseHeaderFilterImage
		m.lnSelectWas = SELECT()
		llUseHeaderFilterImage = .F.
		m.lcAscendingSort      = 'N'
		
		IF This.TemplateLocate(m.tnTemplatePkID)
			m.llLockScreenWas = thisform.LockScreen
			thisform.LockScreen = .T.
			This.ClearHeaderSortImages()
			This.RestoreColumnFilters(m.tnTemplatePkID)
			this.RestoreCustomColumnFilters(m.tnTemplatePkID)
			this.RestoreColumnSort(m.tnTemplatePkID, @m.lcAscendingSort)
			
			this.applyfilter()
			m.llIsCombobox = .F.
			IF TYPE("this.currentcolumn") = "O" AND TYPE("this.currentcolumn.currentcontrol") = "C" AND !EMPTY(this.currentcolumn.currentcontrol)
				m.loActiveControlInColumn = EVALUATE("this.currentcolumn." + this.currentcolumn.currentcontrol)
				IF LOWER(ALLTRIM(m.loActiveControlInColumn.Baseclass)) = "combobox"
					m.llIsCombobox = .T.
				ENDIF
				IF !this.applysort(m.llIsCombobox, this.currentcolumn, m.lcAscendingSort)
					m.lcAscendingSort = "N"
				ENDIF
			ENDIF
			this.setHeaderImages()
			IF TYPE("this.currentcolumn") = "O" AND TYPE("this.currentcolumn.currentcontrol") = "C" AND !EMPTY(this.currentcolumn.currentcontrol)
		      *< m.loHeaderObject = this.currentcolumn.Controls[1]
				m.loHeaderObject = this.currentcolumn.Header1
				m.lcHeaderImage  = UPPER(JUSTFNAME(m.loHeaderObject.picture))
		        IF !EMPTY(m.lcHeaderImage) AND INLIST(m.lcHeaderImage,UPPER(This.HeaderFilterImage),UPPER(This.HeaderFilterDescendingImage),UPPER(This.HeaderFilterAscendingImage))	    
			      m.llUseHeaderFilterImage = .T.
			    ENDIF
				DO CASE
				  CASE m.lcAscendingSort = 'A' && Ascending
				      IF m.llUseHeaderFilterImage
			            m.loHeaderObject.Picture = This.HeaderFilterAscendingImage      && Show Filter Ascending Image
			          ELSE 
					    m.loHeaderObject.Picture = This.HeaderAscendingImage            && Ascending Sort Order
					  ENDIF   
					  
				  CASE m.lcAscendingSort = 'D' && Descending
				      IF m.llUseHeaderFilterImage
			            m.loHeaderObject.Picture = This.HeaderFilterDescendingImage     && Show Filter Descending Image
			          ELSE 
					    m.loHeaderObject.Picture = This.HeaderDescendingImage           && Descending Sort Order
					  ENDIF  
					  
				  OTHERWISE && Not Sort Order
				      IF m.llUseHeaderFilterImage
		  		        m.loHeaderObject.Picture = This.HeaderFilterImage               && Show Filter Image
		              ELSE 
		  		        m.loHeaderObject.Picture = ''                                   && No Sort Image (mothing)
		  		      ENDIF 
				ENDCASE 
			ENDIF
			thisform.LockScreen = m.llLockScreenWas
		ENDIF
		SELECT (m.lnSelectWas)
		
	ENDPROC

	PROCEDURE templateclear		&& INTERNAL USE: Used by the grid templates screen when the user selects the blank in the templates combobox to clear any previously selected filters and sorts.
		LOCAL loColumnObject, loHeaderObject
		WITH this
			DIMENSION .acolumnfilters(1, 3)
			STORE .F. TO .acolumnfilters
			DIMENSION .customcolumnfilters(1, 3)
			STORE .F. TO .customcolumnfilters
			.clearfilter()
			.applysort()
			FOR EACH loColumnObject IN .GridObject.columns
				*< m.loHeaderObject = m.loColumnObject.Controls(1)
		      m.loHeaderObject = m.loColumnObject.Header1
				STORE '' TO  m.loHeaderObject.picture, m.loHeaderObject.Tag
			ENDFOR
		ENDWITH
		
	ENDPROC

	PROCEDURE templatecreateindex		&& This method is called to create the index tag(s) for the gridextras template table.
		***************************************
		*!* This method is used to reindex the template table.
		*!* It is designed to be called when table is created or
		*!* independently in the development environment if the index is corrupted.
		*!* It is assumed developer will account for the index in their own application
		*!* reindexing routine.
		***************************************
		
		LOCAL lcReturnError, lcTemplateTableJustStem, loException AS EXCEPTION, lcCollateSequence, lcOldCollate
		
		m.lcTemplateTable = EVALUATE(THIS.TemplateTable)
		m.lcTemplateTableJustStem = JUSTSTEM(m.lcTemplateTable)
		m.lcCollateSequence = UPPER(THIS.TemplateIndexCollateSequence)
		m.lcReturnError = ""
		
		*!* Verify valid collation sequence set
		IF INLIST(m.lcCollateSequence, ;
				[ARABIC],[CZECH],[DUTCH],[GENERAL],[GERMAN],[GREEK],[HEBREW],[HUNGARY], ;
				[ICELAND],[JAPANESE],[KOREAN],[MACHINE],[NORDAN],[PINYIN],[POLISH],[RUSSIAN], ;
				[SLOVAK],[SPANISH],[STROKE],[SWEFIN],[THAI],[TURKISH],[UNIQWT])
		*!* All is well - valid selection made
		ELSE
		*!* Illegal one set - default to VFP default
			THIS.TemplateIndexCollateSequence = "MACHINE"
		ENDIF
		
		m.lcCollateSequence = UPPER(THIS.TemplateIndexCollateSequence)
		
		*!* If the developer does not pick a valid collation for the DBF code page VFP will
		*!* trigger an error #1915 (Collating sequence "name" is not found). We have left this
		*!* responsibility to the developer since most won't be changing from Machine anyway
		*!* based on the fact the only index is numeric.
		TRY
			m.lcOldCollate = SET("Collate")
			SET COLLATE TO (lcCollateSequence)
			SELECT (m.lcTemplateTableJustStem)
			DELETE TAG ALL
			INDEX ON PkID TAG PkID
			SET COLLATE TO (lcOldCollate)
		CATCH TO m.loException
			m.lcReturnError = m.lcReturnError + m.loException.MESSAGE ;
				+ " (" + TRANSFORM(m.loException.ERRORNO) + ") in " ;
				+ LOWER(PROGRAM()) + " on " + TRANSFORM(m.loException.LINENO)
		ENDTRY
		
		RETURN (m.lcReturnError)
		
	ENDPROC

	PROCEDURE templatecreatetable		&& This method is called to create the gridextras template table.
		*************************************
		*!* This method and the following properties allow the
		*!* class to create the template storage table if it does not exist.
		*************************************
		
		LOCAL lcReturnError, lcTableCodePage, lcTableFree, lcTemplateTable, lcTemplateTableJustStem, loException AS EXCEPTION
		
		m.lcReturnError = ""
		m.lcTemplateTable = EVALUATE(THIS.TemplateTable)
		
		IF !FILE(m.lcTemplateTable)
			m.lcTemplateTableJustStem = JUSTSTEM(m.lcTemplateTable)
			DIMENSION laCodePage[2,26]
			laCodePage[1,01] = 437
			laCodePage[2,01] = [U.S. MS-DOS]
			laCodePage[1,02] = 620
			laCodePage[2,02] = [Mazovia (Polish) MS-DOS]
			laCodePage[1,03] = 737
			laCodePage[2,03] = [Greek MS-DOS (437G)]
			laCodePage[1,04] = 850
			laCodePage[2,04] = [International MS-DOS]
			laCodePage[1,05] = 852
			laCodePage[2,05] = [Eastern European MS-DOS]
			laCodePage[1,06] = 857
			laCodePage[2,06] = [Turkish MS-DOS]
			laCodePage[1,07] = 861
			laCodePage[2,07] = [Icelandic MS-DOS]
			laCodePage[1,08] = 865
			laCodePage[2,08] = [Nordic MS-DOS]
			laCodePage[1,09] = 866
			laCodePage[2,09] = [Russian MS-DOS]
			laCodePage[1,10] = 874
			laCodePage[2,10] = [Thai Windows]
			laCodePage[1,11] = 895
			laCodePage[2,11] = [Kamenicky (Czech) MS-DOS]
			laCodePage[1,12] = 932
			laCodePage[2,12] = [Japanese Windows]
			laCodePage[1,13] = 936
			laCodePage[2,13] = [Chinese Simplified (PRC, Singapore) Windows]
			laCodePage[1,14] = 949
			laCodePage[2,14] = [Korean Windows]
			laCodePage[1,15] = 950
			laCodePage[2,15] = [Traditional Chinese (Hong Kong SAR, Taiwan) Windows]
			laCodePage[1,16] = 1250
			laCodePage[2,16] = [Eastern European Windows]
			laCodePage[1,17] = 1251
			laCodePage[2,17] = [Russian Windows]
			laCodePage[1,18] = 1252
			laCodePage[2,18] = [Windows ANSI]
			laCodePage[1,19] = 1253
			laCodePage[2,19] = [Greek Windows]
			laCodePage[1,20] = 1254
			laCodePage[2,20] = [Turkish Windows]
			laCodePage[1,21] = 1255
			laCodePage[2,21] = [Hebrew Windows]
			laCodePage[1,22] = 1256
			laCodePage[2,22] = [Arabic Windows]
			laCodePage[1,23] = 10000
			laCodePage[2,23] = [Standard Macintosh]
			laCodePage[1,24] = 10006
			laCodePage[2,24] = [Greek Macintosh]
			laCodePage[1,25] = 10007
			laCodePage[2,25] = [Russian Macintosh]
			laCodePage[1,26] = 10029
			laCodePage[2,26] = [Macintosh EE]
		
			IF EMPTY(THIS.TemplateTableCodePage)
				m.lcTableCodePage = SPACE(0)
			ELSE
			*!* Verify the code page numeric
				IF VARTYPE(THIS.TemplateTableCodePage) = "C"
					TRY
						THIS.TemplateTableCodePage = VAL(THIS.TemplateTableCodePage)
					CATCH TO m.loException
						THIS.TemplateTableCodePage = 0
					ENDTRY
				ENDIF
		
			*!* Verify the code page is valid
				lnRow = ASCAN(laCodePage, THIS.TemplateTableCodePage)
		
				IF lnRow > 0
					m.lcTableCodePage = " CODEPAGE = " + ;
						TRANSFORM(THIS.TemplateTableCodePage) + ;
						SPACE(1)
				ELSE
					m.lcTableCodePage = SPACE(0)
				ENDIF
			ENDIF
		
			IF THIS.TemplateTableFree
				m.lcTableFree = " FREE "
			ELSE
				IF EMPTY(SET("Database"))
			*!* No database selected so we have to make it free
					m.lcTableFree = " FREE "
				ELSE
					m.lcTableFree = SPACE(0)
				ENDIF
			ENDIF
		
			TRY
				CREATE TABLE (m.lcTemplateTable) &lcTableFree &lcTableCodePage ;
					(PkID        I NOT NULL AUTOINC NEXTVALUE 1 STEP 1, ;
					Template    C(50), ;
					GridName    C(254), ;
					SortAsc     C(1), ;
					ColName     C(50), ;
					filtercust  M, ;
					filtercol   M, ;
					filterglob  M, ;
					globala     C(10))
		
			*!* Create indexes, which returns any error message to be returned
			*!* from this method to the calling method.
				m.lcReturnError = m.lcReturnError + THIS.TemplateCreateIndex()
		
			*!* Close and reopen in shared mode
				USE IN (SELECT(m.lcTemplateTableJustStem))
		
				IF TYPE("m.lcTemplateTable") = "C" AND FILE(m.lcTemplateTable)
					USE (m.lcTemplateTable) IN 0 SHARED
					SELECT (m.lcTemplateTableJustStem)
				ENDIF
		
			CATCH TO m.loException
				m.lcReturnError = m.lcReturnError ;
					+ m.loException.MESSAGE ;
					+ " (" + TRANSFORM(m.loException.ERRORNO) + ") in " ;
					+ LOWER(PROGRAM()) + " on " + TRANSFORM(m.loException.LINENO)
			ENDTRY
		ENDIF
		
		RETURN (m.lcReturnError)
		
	ENDPROC

	PROCEDURE templatedelete		&& INTERNAL USE: Used by the grid templates screen when the user chooses to delete a selected template.
		LPARAMETERS tnTemplatePkID
		LOCAL lnSelectWas
		m.lnSelectWas = SELECT()
		IF This.TemplateLocate(m.tnTemplatePkID)
			DELETE
		ENDIF
		SELECT (m.lnSelectWas)
		
	ENDPROC

	PROCEDURE templatelocate		&& INTERNAL USE: Used by the grid templates screen to select the template table and locate the template that matches the user's selection.
		LPARAMETERS tnTemplatePkID
		LOCAL lcTemplateTable, lcTemplateTableJustStem, lcTemplateGrid, lcTemplateName, llReturn
		m.llReturn = .F.
		m.lcTemplateTable = EVALUATE(this.templatetable)
		m.lcTemplateTableJustStem = JUSTSTEM(m.lcTemplateTable)
		IF TYPE("m.lcTemplateTable") = "C" AND FILE(m.lcTemplateTable)
			IF !USED(m.lcTemplateTableJustStem)
				USE (m.lcTemplateTable) IN 0 SHARED
			ENDIF
			SELECT (m.lcTemplateTableJustStem)
			IF TYPE("m.tnTemplatePkID") = "N"
				m.llReturn = (m.tnTemplatePkID = EVALUATE( m.lcTemplateTableJustStem + ".pkid") OR SEEK(m.tnTemplatePkID, m.lcTemplateTableJustStem, "pkid"))
			ELSE
				IF TYPE("m.tnTemplatePkID") = "C"
					m.tnTemplatePkID = UPPER(ALLTRIM(m.tnTemplatePkID))
					m.lcTemplateGrid = GETWORDNUM(m.tnTemplatePkID, 1, ":")
					m.lcTemplateName = GETWORDNUM(m.tnTemplatePkID, 2, ":")
					m.llReturn = (UPPER(ALLTRIM(m.lcTemplateGrid)) == UPPER(ALLTRIM(gridname)) and ;
									 UPPER(ALLTRIM(m.lcTemplateName)) == UPPER(ALLTRIM(template)))
					IF !m.llReturn
						LOCATE FOR m.lcTemplateGrid == UPPER(ALLTRIM(gridname)) AND m.lcTemplateName == UPPER(ALLTRIM(template))
						m.llReturn = FOUND(m.lcTemplateTableJustStem)
					ENDIF
				ENDIF
			ENDIF
		ENDIF
		RETURN m.llReturn
	ENDPROC

	PROCEDURE templatesave		&& INTERNAL USE: Used by the grid templates screen to save a new template to the templates list (see templatetable property)
		LPARAMETERS tcGridName, tcTemplateName
		LOCAL lnSelectWas, lnTemplatePkID
		m.lnSelectWas = SELECT()
		IF !This.TemplateLocate(m.tcGridName + ":" + m.tcTemplateName)
			APPEND BLANK
			replace template WITH m.tcTemplateName, gridname WITH m.tcGridName
			m.lnTemplatePkID = pkid
			this.saveacolumnfilters(m.lnTemplatePkID)
			this.savecustomcolumnfilters(m.lnTemplatePkID)
			this.savecolumnsort(m.lnTemplatePkID)
		ELSE
			m.lnTemplatePkID = pkid
			this.saveacolumnfilters(m.lnTemplatePkID)
			this.savecustomcolumnfilters(m.lnTemplatePkID)
			this.savecolumnsort(m.lnTemplatePkID)
		ENDIF
		SELECT (m.lnSelectWas)
		
	ENDPROC

ENDDEFINE

DEFINE CLASS gridextratemplates AS image 
 	*< CLASSDATA: Baseclass="image" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: resizeupdate		&& INTERNAL USE: Bound to the target grid's resize event to ensure that this image stays in the proper position at the bottom left of the target grid.
		*m: zorderupdate		&& INTERNAL USE: Bound to the target grid's zorder property to ensure that this image stays visible and doesn't end up hidden behind the target grid it is meant to provide the template features for.
		*p: gridextrasobject		&& INTERNAL USE: Holds a reference to the GridExtra class instance that added this image to the form, container, or page that the target grid resides in.
		*p: gridobject		&& INTERNAL USE: Holds a reference to the target grid.
		*p: gridutils		&& INTERNAL USE: Holds a reference to the Grid Templates form class (GridUtils) so that it doesn't go out of scope when created.
	*</DefinedPropArrayMethod>

	Anchor = 12
	gridextrasobject = .NULL.		&& INTERNAL USE: Holds a reference to the GridExtra class instance that added this image to the form, container, or page that the target grid resides in.
	gridobject = .NULL.		&& INTERNAL USE: Holds a reference to the target grid.
	gridutils = .NULL.		&& INTERNAL USE: Holds a reference to the Grid Templates form class (GridUtils) so that it doesn't go out of scope when created.
	Height = 16
	Name = "gridextratemplates"
	Picture = table_sql_view16.png
	Stretch = 1
	Visible = .F.
	Width = 18
	
	PROCEDURE Click
		this.gridextrasobject.ShowTemplatesForm()
	ENDPROC

	PROCEDURE Init
		LPARAMETERS toGridExtras
		this.gridextrasobject = m.toGridExtras
		this.ZOrder(0)
	ENDPROC

	PROCEDURE resizeupdate		&& INTERNAL USE: Bound to the target grid's resize event to ensure that this image stays in the proper position at the bottom left of the target grid.
		LOCAL lnAnchorWas
		m.lnAnchorWas = this.Anchor
		this.Anchor = 0
		this.Left = (This.GridObject.Left + This.GridObject.Width - 19)
		IF INLIST(This.GridObject.scrollbars, 0, 2)
			this.Top = (This.GridObject.Top + This.GridObject.Height + 1)
		ELSE
			this.Top = (This.GridObject.Top + This.GridObject.Height - 18)
		ENDIF
		this.Anchor = m.lnAnchorWas
		this.ZOrder(0)
	ENDPROC

	PROCEDURE zorderupdate		&& INTERNAL USE: Bound to the target grid's zorder property to ensure that this image stays visible and doesn't end up hidden behind the target grid it is meant to provide the template features for.
		LPARAMETERS tnzOrder
		this.zorder(0)
		
	ENDPROC

ENDDEFINE

DEFINE CLASS gridsearchandfilter AS form 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Image1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblMore" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="shpSplitter" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Check1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Grid1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Grid1.Column1.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Grid1.Column1.Check1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Grid1.Column2.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Grid1.Column2.Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Gridcustomfilter1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="tmrCheckform" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="tmrFadeform" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdFilter" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Image2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdClearFilter" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdSearch" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtSearch" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdExit" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: buildfilter		&& INTERNAL USE: Used to build the filter. Basically filling the CustomColumnFilters and AColumnFilters arrays of the GridExtra class.
		*m: checkforselectall		&& INTERNAL USE: Determines whether the alias specified by UniqueCursorName has .T. in the checked field for all records and then sets the Check1 control's value appropriately.
		*m: clearfilter		&& INTERNAL USE: Clears any references for the target column's controlsource from the AColumnFilters and CustomColumnFilters array properties of the GridExtra class instance.
		*m: retrievepreviouschecks		&& INTERNAL USE: Used to retrieve what, if any, selections were checked in the grid the last time the user was in this form.
		*m: retrievepreviouscustomfilter		&& INTERNAL USE: Used to retrieve what, if any, selections were made by the user in the gridcustomfilter container the last time the user was in this form.
		*m: search		&& INTERNAL USE: Used to incrementally search within the target column for the value specified by the user in the txtSearch control.
		*m: setanchors		&& INTERNAL USE: Used to both set and clear the anchor property of certain controls on this form allowing it to be expanded, resized, and collapsed appropriately.
		*m: setup		&& INTERNAL USE: Used to setup the initial environment for this form and some default values for controls.
		*m: showfilteroptions		&& INTERNAL USE: Used to expand or collapse this form based on the user click the "More..." or "Less..." label displayed beneath the txtSearch control.
		*p: columncontrolsource		&& INTERNAL USE: Holds a reference to the value for the target column's controlsource.
		*p: columnobject		&& INTERNAL USE: Holds a reference to the target column.
		*p: delimiter		&& INTERNAL USE: Determines what character(s) are used to delineate filter selection values. This ensures that "cap" doesn't match "cape" regardless of Exact and Ansi settings by making them "||cap||" and "||cape||" for instance.
		*p: findnext		&& INTERNAL USE: Used by the incremental search feature to find the next matching record within the target grid's recordsource.
		*p: globalarrayname		&& INTERNAL USE: Has the same value as the GlobalArrayName property of the GridExtra class. The global array is an array property added to the _screen that stores the filter strings so that we don't need to worry about scope.
		*p: gridextraobject		&& INTERNAL USE: Holds a reference to the GridExtra class instance that called this form.
		*p: gridrecordsource		&& INTERNAL USE: Holds a reference to the target grid's recordsource value.
		*p: indexcustomcolumnfilter		&& INTERNAL USE: Used to tell the class where (index/row) within the CustomColumnFilters array property of the GridExtra class instance that called this form the custom filter should be saved.
		*p: lastuseraction		&& INTERNAL USE: Holds the SECONDS since midnight when the last user interaction with this form occurred. Ensures that fading of the form will not occur while the user is actively using the form. See the FadeWait property of the GridExtra class.
		*p: rundeactivaterelease		&& INTERNAL USE: Determines whether or not this form should be be released when the deactivate even fires.
		*p: uniquecursorname		&& INTERNAL USE: Holds a unique (unused) cursor name that this class uses to create the recordsource for the filter selection grid.
		*p: _fade		&& INTERNAL USE: Used to facilitate the opacity of the fade as it is fading in or out.
		*p: _infademode		&& INTERNAL USE: Used to tell the class whether the form is fading or not.
		*p: _inform		&& INTERNAL USE: Used to tell the class whether the mouse (cursor) is within the boundaries of the Search/Filter form or not.
	*</DefinedPropArrayMethod>

	AlwaysOnTop = .T.
	BackColor = 255,255,255
	BorderStyle = 3
	Caption = ""
	Closable = .F.
	columncontrolsource = 		&& INTERNAL USE: Holds a reference to the value for the target column's controlsource.
	columnobject = NULL		&& INTERNAL USE: Holds a reference to the target column.
	ControlBox = .F.
	delimiter = ||		&& INTERNAL USE: Determines what character(s) are used to delineate filter selection values. This ensures that "cap" doesn't match "cape" regardless of Exact and Ansi settings by making them "||cap||" and "||cape||" for instance.
	Desktop = .T.
	DoCreate = .T.
	findnext = .F.		&& INTERNAL USE: Used by the incremental search feature to find the next matching record within the target grid's recordsource.
	globalarrayname = .F.		&& INTERNAL USE: Has the same value as the GlobalArrayName property of the GridExtra class. The global array is an array property added to the _screen that stores the filter strings so that we don't need to worry about scope.
	gridextraobject = NULL		&& INTERNAL USE: Holds a reference to the GridExtra class instance that called this form.
	gridrecordsource = 		&& INTERNAL USE: Holds a reference to the target grid's recordsource value.
	Height = 382
	indexcustomcolumnfilter = 0		&& INTERNAL USE: Used to tell the class where (index/row) within the CustomColumnFilters array property of the GridExtra class instance that called this form the custom filter should be saved.
	lastuseraction = 0		&& INTERNAL USE: Holds the SECONDS since midnight when the last user interaction with this form occurred. Ensures that fading of the form will not occur while the user is actively using the form. See the FadeWait property of the GridExtra class.
	Left = 0
	MaxButton = .F.
	MinButton = .F.
	Movable = .F.
	Name = "gridsearchandfilter"
	rundeactivaterelease = .T.		&& INTERNAL USE: Determines whether or not this form should be be released when the deactivate even fires.
	ShowTips = .T.
	TitleBar = 0
	Top = 0
	uniquecursorname = 		&& INTERNAL USE: Holds a unique (unused) cursor name that this class uses to create the recordsource for the filter selection grid.
	Width = 228
	WindowType = 0
	_fade = 255		&& INTERNAL USE: Used to facilitate the opacity of the fade as it is fading in or out.
	_infademode = .T.		&& INTERNAL USE: Used to tell the class whether the form is fading or not.
	_inform = .T.		&& INTERNAL USE: Used to tell the class whether the mouse (cursor) is within the boundaries of the Search/Filter form or not.

	ADD OBJECT 'Check1' AS checkbox WITH ;
		Alignment = 0, ;
		Anchor = 3, ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = " Select All", ;
		ForeColor = 128,128,255, ;
		Height = 17, ;
		Left = 5, ;
		Name = "Check1", ;
		TabIndex = 6, ;
		Top = 142, ;
		Value = .T., ;
		Width = 71
		*< END OBJECT: BaseClass="checkbox" />

	ADD OBJECT 'cmdClearFilter' AS commandbutton WITH ;
		Anchor = 3, ;
		Caption = "", ;
		Height = 26, ;
		Left = 168, ;
		Name = "cmdClearFilter", ;
		Picture = clearfilter16.bmp, ;
		PicturePosition = 4, ;
		TabIndex = 3, ;
		ToolTipText = "Clear Existing Filter", ;
		Top = 4, ;
		Width = 28
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdExit' AS commandbutton WITH ;
		Anchor = 3, ;
		Caption = "", ;
		Height = 26, ;
		Left = 196, ;
		Name = "cmdExit", ;
		Picture = close16.bmp, ;
		PicturePosition = 4, ;
		TabIndex = 4, ;
		ToolTipText = "Cancel and Exit", ;
		Top = 4, ;
		Width = 28
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdFilter' AS commandbutton WITH ;
		Caption = "Filter  ", ;
		Height = 26, ;
		Left = 160, ;
		Name = "cmdFilter", ;
		Picture = addfilter16.bmp, ;
		PictureMargin = 2, ;
		PicturePosition = 4, ;
		TabIndex = 8, ;
		ToolTipText = "Apply Filter and Exit", ;
		Top = 352, ;
		Width = 64
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdSearch' AS commandbutton WITH ;
		Anchor = 0, ;
		Caption = "", ;
		Height = 25, ;
		Left = 140, ;
		Name = "cmdSearch", ;
		Picture = search16.bmp, ;
		TabIndex = 2, ;
		ToolTipText = "Search", ;
		Top = 4, ;
		Width = 28
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'Grid1' AS grid WITH ;
		AllowHeaderSizing = .F., ;
		AllowRowSizing = .F., ;
		ColumnCount = 2, ;
		DeleteMark = .F., ;
		GridLines = 0, ;
		HeaderHeight = 0, ;
		Height = 182, ;
		Highlight = .F., ;
		HighlightRow = .F., ;
		HighlightRowLineWidth = 0, ;
		Left = -1, ;
		Name = "Grid1", ;
		RecordMark = .F., ;
		ScrollBars = 2, ;
		SplitBar = .F., ;
		TabIndex = 7, ;
		Top = 165, ;
		Width = 230, ;
		Column1.Name = "Column1", ;
		Column1.Resizable = .F., ;
		Column1.Sparse = .F., ;
		Column1.Width = 23, ;
		Column2.Name = "Column2", ;
		Column2.ReadOnly = .T., ;
		Column2.Resizable = .F., ;
		Column2.Width = 183
		*< END OBJECT: BaseClass="grid" />

	ADD OBJECT 'Grid1.Column1.Check1' AS checkbox WITH ;
		Alignment = 0, ;
		Caption = "", ;
		Centered = .T., ;
		Height = 17, ;
		Left = 12, ;
		Name = "Check1", ;
		Top = 11, ;
		Width = 60
		*< END OBJECT: BaseClass="checkbox" />

	ADD OBJECT 'Grid1.Column1.Header1' AS header WITH ;
		Caption = "Header1", ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'Grid1.Column2.Header1' AS header WITH ;
		Caption = "Header1", ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'Grid1.Column2.Text1' AS textbox WITH ;
		BackColor = 255,255,255, ;
		BorderStyle = 0, ;
		ForeColor = 0,0,0, ;
		Margin = 0, ;
		Name = "Text1", ;
		ReadOnly = .T.
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'Gridcustomfilter1' AS gridcustomfilter WITH ;
		Anchor = 3, ;
		Left = 4, ;
		Name = "Gridcustomfilter1", ;
		TabIndex = 5, ;
		Top = 60, ;
		Combo1.Left = 1, ;
		Combo1.Name = "Combo1", ;
		Text1.Height = 23, ;
		Text1.Left = 21, ;
		Text1.Name = "Text1", ;
		Text1.Top = 27, ;
		Text1.Width = 170, ;
		Text2.Height = 23, ;
		Text2.Left = 21, ;
		Text2.Name = "Text2", ;
		Text2.Top = 52, ;
		Text2.Width = 170
		*< END OBJECT: ClassLib="gridextras.vcx" BaseClass="container" />

	ADD OBJECT 'Image1' AS image WITH ;
		Anchor = 3, ;
		Height = 16, ;
		Left = 5, ;
		Name = "Image1", ;
		Picture = showfilters16.bmp, ;
		Top = 33, ;
		Width = 16
		*< END OBJECT: BaseClass="image" />

	ADD OBJECT 'Image2' AS image WITH ;
		Height = 25, ;
		Left = 3, ;
		Name = "Image2", ;
		Picture = reverse.png, ;
		ToolTipText = "Reverse selection", ;
		Top = 353, ;
		Width = 36
		*< END OBJECT: BaseClass="image" />

	ADD OBJECT 'lblMore' AS label WITH ;
		Anchor = 3, ;
		AutoSize = .F., ;
		BackStyle = 0, ;
		Caption = "More...", ;
		ForeColor = 128,128,255, ;
		Height = 17, ;
		Left = 24, ;
		Name = "lblMore", ;
		TabIndex = 10, ;
		Top = 33, ;
		Width = 38
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'shpSplitter' AS shape WITH ;
		Anchor = 11, ;
		Height = 1, ;
		Left = -4, ;
		Name = "shpSplitter", ;
		SpecialEffect = 0, ;
		Top = 54, ;
		Width = 235
		*< END OBJECT: BaseClass="shape" />

	ADD OBJECT 'tmrCheckform' AS checkform WITH ;
		Left = 42, ;
		Name = "tmrCheckform", ;
		Top = 355
		*< END OBJECT: ClassLib="gridextras.vcx" BaseClass="timer" />

	ADD OBJECT 'tmrFadeform' AS fadeform WITH ;
		Left = 72, ;
		Name = "tmrFadeform", ;
		Top = 355
		*< END OBJECT: ClassLib="gridextras.vcx" BaseClass="timer" />

	ADD OBJECT 'txtSearch' AS textbox WITH ;
		Anchor = 0, ;
		FontItalic = .T., ;
		ForeColor = 128,128,255, ;
		Format = "K", ;
		Height = 23, ;
		Left = 5, ;
		Name = "txtSearch", ;
		SelectOnEntry = .T., ;
		TabIndex = 1, ;
		Top = 5, ;
		Value = Search, ;
		Width = 134
		*< END OBJECT: BaseClass="textbox" />
	
	PROCEDURE buildfilter		&& INTERNAL USE: Used to build the filter. Basically filling the CustomColumnFilters and AColumnFilters arrays of the GridExtra class.
		LOCAL llAllChecked, lnFilterCounter, lnOriginalLen, lcColumnName
		LOCAL llNoneChecked, lcAtCommand, lcGlobalArray, lnIndexCustomColumnFilter
		
		WITH THIS
			IF .GridExtraObject.CaseSensitive
				m.lcAtCommand= "AT"
			ELSE
				m.lcAtCommand= "ATC"
			ENDIF
			.ClearFilter()
			m.llAllChecked = .T.
			m.llNoneChecked = .T.
			m.lnOriginalLen = ALEN(.GridExtraObject.acolumnfilters, 1)
			IF TYPE("This.GridExtraObject.AColumnFilters(1,2)") != "C" AND m.lnOriginalLen = 1
				m.lnOriginalLen = 0
			ENDIF
		
			****************************************
			*!* Save custom filter settings so they can be restored
			IF .IndexCustomColumnFilter < 1
				.IndexCustomColumnFilter = ALEN(.GridExtraObject.CustomColumnFilters,1) + 1
				DIMENSION .GridExtraObject.CustomColumnFilters(.IndexCustomColumnFilter, 5)
			ENDIF
			.GridExtraObject.CustomColumnFilters(.IndexCustomColumnFilter, 1) = .ColumnObject.NAME
			.GridExtraObject.CustomColumnFilters(.IndexCustomColumnFilter, 2) = .GridCustomFilter1.Combo1.LISTINDEX
			.GridExtraObject.CustomColumnFilters(.IndexCustomColumnFilter, 3) = .GridCustomFilter1.Text1.VALUE
			.GridExtraObject.CustomColumnFilters(.IndexCustomColumnFilter, 4) = .GridCustomFilter1.Text2.VALUE
			.GridExtraObject.CustomColumnFilters(.IndexCustomColumnFilter, 5) = .GridCustomFilter1.FilterString
			****************************************
		
			m.lcGlobalArray = [_GEScr.] + .GlobalArrayname
			m.lnFilterCounter = m.lnOriginalLen
			IF !.check1.VALUE
				GO TOP IN (.UniqueCursorName)
				m.lcColumnName = ALLTRIM(.ColumnObject.NAME)
				DO WHILE !EOF(.UniqueCursorName)
					IF EVALUATE(.UniqueCursorName + ".checked")
						m.llNoneChecked = .F.
						IF m.lnFilterCounter = m.lnOriginalLen
							m.lnFilterCounter = m.lnFilterCounter + 1
							DIMENSION &lcGlobalArray.(m.lnFilterCounter,1)
							DIMENSION .GridExtraObject.AColumnFilters(m.lnFilterCounter,3)
							.GridExtraObject.AColumnFilters(m.lnFilterCounter,1) = "("
							.GridExtraObject.AColumnFilters(m.lnFilterCounter,2) = m.lcColumnName
							m.lnFilterCounter = m.lnFilterCounter + 1
							DIMENSION &lcGlobalArray.(m.lnFilterCounter,1)
							DIMENSION .GridExtraObject.AColumnFilters(m.lnFilterCounter,3)
							.GridExtraObject.AColumnFilters(m.lnFilterCounter,1) = m.lcAtCommand + "([" + .DELIMITER + "]+TRANSFORM(" + .ColumnControlSource + ")+[" + .DELIMITER + "],"+;
								[ _GEScr.] + .GlobalArrayname + [(] + ALLTRIM(STR(m.lnFilterCounter)) + [,1)]
							.GridExtraObject.AColumnFilters(m.lnFilterCounter,2) = m.lcColumnName
							.GridExtraObject.AColumnFilters(m.lnFilterCounter,3) = ;
								.DELIMITER + TRANSFORM(EVALUATE(.UniqueCursorName + ".actvalues")) + .DELIMITER
						ELSE
							.GridExtraObject.AColumnFilters(m.lnFilterCounter,3) = ;
								.GridExtraObject.AColumnFilters(m.lnFilterCounter,3) + ;
								TRANSFORM(EVALUATE(.UniqueCursorName + ".actvalues")) + .DELIMITER
						ENDIF
					ELSE
						m.llAllChecked = .F.
					ENDIF
					SKIP 1 IN (.UniqueCursorName)
				ENDDO
			ENDIF
			IF m.lnFilterCounter = 0
				DIMENSION .GridExtraObject.AColumnFilters(1,3)
				STORE .F. TO .GridExtraObject.AColumnFilters
				DIMENSION &lcGlobalArray.(1,1)
				STORE .F. TO &lcGlobalArray
			ELSE
				IF !m.llAllChecked AND !m.llNoneChecked
					&lcGlobalArray.(m.lnFilterCounter,1) = .GridExtraObject.AColumnFilters(m.lnFilterCounter,3)
					.GridExtraObject.AColumnFilters(m.lnFilterCounter,1) = ;
						.GridExtraObject.AColumnFilters(m.lnFilterCounter,1) + ")>0"
					m.lnFilterCounter = m.lnFilterCounter + 1
					DIMENSION &lcGlobalArray.(m.lnFilterCounter,1)
					DIMENSION .GridExtraObject.AColumnFilters(m.lnFilterCounter,3)
					.GridExtraObject.AColumnFilters(m.lnFilterCounter,1) = ")"
					.GridExtraObject.AColumnFilters(m.lnFilterCounter,2) = m.lcColumnName
					&lcGlobalArray.(m.lnFilterCounter,1) = ""
				ENDIF
			ENDIF
		ENDWITH
		
	ENDPROC

	PROCEDURE checkforselectall		&& INTERNAL USE: Determines whether the alias specified by UniqueCursorName has .T. in the checked field for all records and then sets the Check1 control's value appropriately.
		LOCAL ARRAY aTemp(1)
		
		WITH THIS
			SELECT checked FROM (.UniqueCursorName) WHERE !checked INTO ARRAY aTemp
			.Check1.VALUE = (_TALLY < 1)
			.Check1.REFRESH()
		ENDWITH
		
	ENDPROC

	PROCEDURE clearfilter		&& INTERNAL USE: Clears any references for the target column's controlsource from the AColumnFilters and CustomColumnFilters array properties of the GridExtra class instance.
		LOCAL lnCounter, lcColumnName, lnIndex, lcGlobalArray, lcFilter
		LOCAL ARRAY aTemp(1,3)
		
		WITH THIS
			DIMENSION aTemp(ALEN(.GridExtraObject.AColumnFilters, 1),3)
			=ACOPY(.GridExtraObject.AColumnFilters, aTemp)
			DIMENSION .GridExtraObject.AColumnFilters(1,3)
			STORE .F. TO .GridExtraObject.AColumnFilters
			m.lcGlobalArray = [_GEScr.]+.GlobalArrayname
			m.lnIndex = 0
			m.lcColumnName = UPPER(ALLTRIM(.ColumnObject.NAME))
			FOR m.lnCounter = 1 TO ALEN(aTemp, 1)
				IF TYPE("aTemp(m.lnCounter,2)") = "C"
					IF UPPER(ALLTRIM(aTemp(m.lnCounter,2))) == m.lcColumnName
						*!*				=ADEL(.GridExtraObject.AColumnFilters, m.lnCounter)
					ELSE
						m.lnIndex = m.lnIndex + 1
						DIMENSION .GridExtraObject.AColumnFilters(m.lnIndex,3)
						DIMENSION &lcGlobalArray.(m.lnIndex,1)
						m.lcFilter = aTemp(m.lnCounter,1)
						m.lcFilter = STRTRAN(m.lcFilter, m.lcGlobalArray+"("+ALLTRIM(STR(m.lnCounter))+",1)", m.lcGlobalArray+"("+ALLTRIM(STR(m.lnIndex))+",1)")
						.GridExtraObject.AColumnFilters(m.lnIndex,1) = m.lcFilter
						.GridExtraObject.AColumnFilters(m.lnIndex,2) = aTemp(m.lnCounter,2)
						.GridExtraObject.AColumnFilters(m.lnIndex,3) = aTemp(m.lnCounter,3)
						&lcGlobalArray.(m.lnIndex,1) = aTemp(m.lnCounter,3)
					ENDIF
				ENDIF
			ENDFOR
			IF .IndexCustomColumnFilter > 0
				.GridExtraObject.CustomColumnFilters(.IndexCustomColumnFilter,5) = ""
			ENDIF
		ENDWITH
		
	ENDPROC

	PROCEDURE Deactivate
		IF !THISFORM.RunDeactivateRelease
			RETURN
		ENDIF
		THISFORM.RELEASE()
		
	ENDPROC

	PROCEDURE Init
		LPARAMETERS toColumnObject, toGridExtraObject
		
		WITH THIS
			.ColumnObject = m.toColumnObject
			.GridExtraObject = m.toGridExtraObject
		ENDWITH
		
		IF TYPE("This.ColumnObject.Name") != "C" OR TYPE("This.GridExtraObject.Name") != "C"
			RETURN .F.
		ENDIF
		m.toGridExtraObject.CreateScreenReference()
		
		WITH THIS
			.UniqueCursorName = m.toGridExtraObject.GlobalArrayName
			.GlobalArrayName = m.toGridExtraObject.GlobalArrayName
			.HEIGHT = .shpSplitter.TOP
			.MINHEIGHT = .HEIGHT
			.MAXHEIGHT = .HEIGHT
			.MAXWIDTH = .WIDTH
			.MINWIDTH = .WIDTH
			.SETUP()
		ENDWITH
		
		IF OS() < "Windows 5.00"
			RETURN
		ENDIF
		
		DECLARE SetWindowLong IN WIN32API AS _Sol_SetWindowLong INTEGER, INTEGER, INTEGER
		DECLARE SetLayeredWindowAttributes IN WIN32API AS _Sol_SetLayeredWindowAttributes INTEGER, STRING, INTEGER, INTEGER
		
		WITH THIS
			_Sol_SetWindowLong(.HWND, -20, 0x00080000)
			_Sol_SetLayeredWindowAttributes(.HWND, 0, 255, 2)
			IF VAL(OS(3))<5
				.tmrCheckForm.INTERVAL = 0 && only available on Windows 2000 or higher
			ELSE
				.tmrCheckForm.INTERVAL = 200
			ENDIF
			IF !.GridExtraObject.Allowgridfilter
				.txtSearch.WIDTH = 162
				.cmdSearch.LEFT = .cmdClearFilter.LEFT
				.cmdClearFilter.VISIBLE = .F.
				.Image1.VISIBLE = .F.
				.lblMore.VISIBLE = .F.
				.MINHEIGHT = .Image1.TOP
				.MAXHEIGHT = .Image1.TOP
				.HEIGHT = .Image1.TOP
				.BORDERSTYLE = 2
			ENDIF
			.txtSearch.ANCHOR = 3
			.cmdSearch.ANCHOR = 3
		ENDWITH
		
	ENDPROC

	PROCEDURE Resize
		LOCAL lnObjectHeight, lnDifference
		
		WITH THIS
			.LastUserAction = SECONDS()
			IF .grid1.ANCHOR != 11
				m.lnObjectHeight = (.grid1.ROWHEIGHT * 3 + 1)
				IF .grid1.HEIGHT < m.lnObjectHeight
					m.lnDifference = (m.lnObjectHeight - .grid1.HEIGHT)
					.HEIGHT = (.HEIGHT + m.lnDifference)
					.SetAnchors(.T.)
				ENDIF
			ELSE
				IF .grid1.ANCHOR != 15
					m.lnObjectHeight = (.cmdFilter.TOP + .cmdFilter.HEIGHT + 4)
					IF .HEIGHT > m.lnObjectHeight
						.HEIGHT = m.lnObjectHeight
						.SetAnchors(.F.)
					ENDIF
				ENDIF
			ENDIF
		ENDWITH
		
	ENDPROC

	PROCEDURE retrievepreviouschecks		&& INTERNAL USE: Used to retrieve what, if any, selections were checked in the grid the last time the user was in this form.
		LOCAL lnCounter, lcColumnName, llFoundOne, lcIndexOneValue, lcIndexTwoValue, lcAtCommand
		
		WITH This
			IF .GridExtraObject.CaseSensitive
				m.lcAtCommand= "AT"
			else
				m.lcAtCommand= "ATC"
			ENDIF
			m.lcColumnName = ALLTRIM(.ColumnObject.name)
			m.llFoundOne = .F.
			m.llDoInitialUpdateToFalse = .T.
			FOR m.lnCounter = 1 TO ALEN(.GridExtraObject.AColumnFilters,1)
				m.lcIndexTwoValue = .GridExtraObject.AColumnFilters(m.lnCounter,2)
				IF TYPE("m.lcIndexTwoValue") = "C"
					m.lcIndexOneValue = .GridExtraObject.AColumnFilters(m.lnCounter,3)
					IF m.lcIndexTwoValue == m.lcColumnName ;
						AND NOT EMPTY(m.lcIndexOneValue)
						IF m.llDoInitialUpdateToFalse
							m.llDoInitialUpdateToFalse = .F.
							UPDATE (.UniqueCursorName) SET checked = .F. WHERE .T.
						ENDIF
						GO TOP IN (.UniqueCursorName)
						DO WHILE !EOF(.UniqueCursorName)
							IF &lcAtCommand.(.delimiter + TRANSFORM(EVALUATE(.UniqueCursorName + ".actvalues")) + .delimiter, m.lcIndexOneValue) > 0
								m.llFoundOne = .T.
								replace checked WITH .T. IN (.UniqueCursorName)
							ENDIF
							SKIP 1 IN (.UniqueCursorName)
						ENDDO
					ENDIF
				ENDIF
			ENDFOR
			IF m.llFoundOne
				.check1.Value = .F.
				GO TOP IN (.UniqueCursorName)
				.grid1.Refresh()
			ENDIF
		ENDWITH
	ENDPROC

	PROCEDURE retrievepreviouscustomfilter		&& INTERNAL USE: Used to retrieve what, if any, selections were made by the user in the gridcustomfilter container the last time the user was in this form.
		LOCAL lnIndexCustomColumnFilter
		WITH THIS
			m.lnIndexCustomColumnFilter = ASCAN(.GridExtraObject.CustomColumnFilters, .ColumnObject.NAME, -1, -1, 1, 15)
			IF m.lnIndexCustomColumnFilter > 0
				.GridCustomFilter1.Combo1.LISTINDEX = .GridExtraObject.CustomColumnFilters(m.lnIndexCustomColumnFilter,2)
				.GridCustomFilter1.Text1.VALUE = .GridExtraObject.CustomColumnFilters(m.lnIndexCustomColumnFilter,3)
				.GridCustomFilter1.Text2.VALUE = .GridExtraObject.CustomColumnFilters(m.lnIndexCustomColumnFilter,4)
				.GridCustomFilter1.Combo1.REFRESH()
				.GridCustomFilter1.Text1.REFRESH()
				.GridCustomFilter1.Text2.REFRESH()
			ENDIF
			.IndexCustomColumnFilter = m.lnIndexCustomColumnFilter
		ENDWITH
		
	ENDPROC

	PROCEDURE search		&& INTERNAL USE: Used to incrementally search within the target column for the value specified by the user in the txtSearch control.
		LOCAL lcControlSource, lcRecordSource, lcAliasWas, lcSearchValue
		WITH THIS
			IF .txtSearch.FONTITALIC
				.txtSearch.SETFOCUS()
			ELSE
				.GridExtraObject.Search(.txtSearch.VALUE, .findnext)
				.findnext = .T.
			ENDIF
		ENDWITH
		
	ENDPROC

	PROCEDURE setanchors		&& INTERNAL USE: Used to both set and clear the anchor property of certain controls on this form allowing it to be expanded, resized, and collapsed appropriately.
		LPARAMETERS tlClearAnchors
		
		WITH THIS
			IF m.tlClearAnchors
				.grid1.ANCHOR = 11
				.cmdFilter.ANCHOR = 8
				.image2.ANCHOR = 0
			ELSE
				.grid1.ANCHOR = 15
				.cmdFilter.ANCHOR = 12
				.image2.ANCHOR = 6
			ENDIF
		ENDWITH
		
	ENDPROC

	PROCEDURE setup		&& INTERNAL USE: Used to setup the initial environment for this form and some default values for controls.
		LOCAL lcRecordSource, lcControlSource, lcCursorName
		LOCAL lcControlSourceJustStem, loActiveControlInColumn
		LOCAL lcColumnCursorName, llActiveControlIsCombobox, lcOrderByClause
		
		WITH THIS
			m.lcRecordSource = ALLTRIM(.ColumnObject.PARENT.RECORDSOURCE)
			m.lcControlSource = ALLTRIM(.ColumnObject.CONTROLSOURCE)
			.GridRecordSource = m.lcRecordSource
			.ColumnControlSource = m.lcControlSource
			m.lcCursorName = .UniqueCursorName
			IF AT(".", m.lcControlSource) > 0
				m.lcControlSourceJustStem = JUSTSTEM(m.lcControlSource)
				IF UPPER(ALLTRIM(m.lcControlSourceJustStem)) != UPPER(ALLTRIM(m.lcRecordSource)) AND USED(m.lcControlSourceJustStem)
					m.lcRecordSource = m.lcControlSourceJustStem
				ENDIF
			ENDIF
			m.loActiveControlInColumn = EVALUATE("this.ColumnObject." + .ColumnObject.CURRENTCONTROL)
			m.llActiveControlIsCombobox = (LOWER(m.loActiveControlInColumn.BASECLASS) = "combobox" AND m.loActiveControlInColumn.BOUNDCOLUMN > 1)
			IF m.llActiveControlIsCombobox
				.GridCustomFilter1.VISIBLE = .F.
			ENDIF
			m.lcOrderByClause = ""
			m.lcDistinct = ""
			IF TYPE(m.lcControlSource) != "M"
				m.lcOrderByClause = "ORDER BY 2"
				m.lcDistinct = "Distinct"
			ENDIF
			IF !.GridExtraObject.CaseSensitive AND TYPE(m.lcControlSource) = "C"
				IF m.llActiveControlIsCombobox
					m.lcColumnCursorName = .GridExtraObject.GetComboCursorName(m.loActiveControlInColumn)
					IF USED(m.lcColumnCursorName)
						SELECT &lcDistinct .T. AS checked, UPPER(disptext) AS fldvalues,  TRANSFORM(fkid) AS actvalues;
							FROM (m.lcRecordSource) WITH (BUFFERING = .T.) INNER JOIN &lcColumnCursorName ON &lcControlSource = &lcColumnCursorName..fkid ;
							&lcOrderByClause ;
							INTO CURSOR &lcCursorName READWRITE
					ENDIF
				ELSE
					SELECT &lcDistinct .T. AS checked, UPPER(&lcControlSource) AS fldvalues, UPPER(&lcControlSource) AS actvalues ;
						FROM (m.lcRecordSource) WITH (BUFFERING = .T.) ;
						&lcOrderByClause ;
						INTO CURSOR &lcCursorName READWRITE
				ENDIF
			ELSE
				IF m.llActiveControlIsCombobox
					m.lcColumnCursorName = .GridExtraObject.GetComboCursorName(m.loActiveControlInColumn)
					IF USED(m.lcColumnCursorName)
						SELECT &lcDistinct .T. AS checked, disptext AS fldvalues, TRANSFORM(fkid) AS actvalues ;
							FROM (m.lcRecordSource) WITH (BUFFERING = .T.) INNER JOIN &lcColumnCursorName ON &lcControlSource = &lcColumnCursorName..fkid ;
							&lcOrderByClause ;
							INTO CURSOR &lcCursorName READWRITE
					ENDIF
				ELSE
					SELECT &lcDistinct .T. AS checked, &lcControlSource AS fldvalues, &lcControlSource AS actvalues ;
						FROM (m.lcRecordSource) WITH (BUFFERING = .T.) ;
						&lcOrderByClause ;
						INTO CURSOR &lcCursorName READWRITE
				ENDIF
			ENDIF
			.RetrievePreviousChecks()
			GO TOP IN (m.lcCursorName)
			WITH .grid1
				.RECORDSOURCE = m.lcCursorName
				IF .COLUMNCOUNT != 2
					.COLUMNCOUNT = 2
				ENDIF
				.Column1.CONTROLSOURCE = "checked"
				.Column2.CONTROLSOURCE = "fldvalues"
				.Column2.FORMAT = THIS.ColumnObject.FORMAT
				.Column2.INPUTMASK = THIS.ColumnObject.INPUTMASK
			ENDWITH
			.GridCustomFilter1.SETUP(.ColumnObject.CONTROLS(1).CAPTION, TYPE(m.lcControlSource), m.lcControlSource)
			.retrievepreviouscustomfilter()
			.LastUserAction = SECONDS()
		ENDWITH
		
	ENDPROC

	PROCEDURE showfilteroptions		&& INTERNAL USE: Used to expand or collapse this form based on the user click the "More..." or "Less..." label displayed beneath the txtSearch control.
		LPARAMETERS tlShowFilterOptions
		
		WITH THIS
			IF m.tlShowFilterOptions
				.MAXHEIGHT = -1
				.MAXWIDTH = -1
				.WIDTH = (.cmdFilter.LEFT + .cmdFilter.WIDTH + 4)
				.HEIGHT = (.cmdFilter.TOP + .cmdFilter.HEIGHT + 4)
				.SetAnchors(.F.)
			ELSE
				.SetAnchors(.T.)
				.WIDTH = (.cmdExit.LEFT + .cmdExit.WIDTH + 4)
				.HEIGHT = .shpSplitter.TOP
				.MAXHEIGHT = .HEIGHT
				.MAXWIDTH = .WIDTH
			ENDIF
		ENDWITH
		
	ENDPROC

	PROCEDURE Check1.GotFocus
		THISFORM.LastUserAction = SECONDS()
		
	ENDPROC

	PROCEDURE Check1.Valid
		LOCAL llValue, lnRecNo
		
		WITH THISFORM
			.LastUserAction = SECONDS()
			IF USED(.UniqueCursorName)
				m.lnRecNo = IIF(!EOF(.UniqueCursorName), RECNO(.UniqueCursorName), 0)
				m.llValue = THIS.VALUE
				REPLACE ALL checked WITH m.llValue IN (.UniqueCursorName)
				IF m.lnRecNo > 0
					GO m.lnRecNo IN (.UniqueCursorName)
				ELSE
					GO BOTTOM IN (.UniqueCursorName)
				ENDIF
				.grid1.REFRESH()
			ENDIF
			.GridCustomFilter1.ClearFilterSettings()
		ENDWITH
		
	ENDPROC

	PROCEDURE cmdClearFilter.Click
		WITH THISFORM
			.LastUserAction = SECONDS()
			WITH .Check1
				IF !.VALUE
					.VALUE = .T.
					.REFRESH()
					.VALID()
				ENDIF
			ENDWITH
			WITH .GridCustomFilter1.Combo1
				IF .LISTINDEX != 1
					.LISTINDEX = 1
					.INTERACTIVECHANGE()
				ENDIF
			ENDWITH
			.BuildFilter()
			.GridExtraObject.ApplyFilter()
			.GridExtraObject.SetHeaderImages()
		ENDWITH
		
	ENDPROC

	PROCEDURE cmdClearFilter.GotFocus
		THISFORM.LastUserAction = SECONDS()
		
	ENDPROC

	PROCEDURE cmdExit.Click
		THISFORM.RELEASE()
		
	ENDPROC

	PROCEDURE cmdExit.GotFocus
		THISFORM.LastUserAction = SECONDS()
		
	ENDPROC

	PROCEDURE cmdFilter.Click
		WITH THISFORM
			.LastUserAction = SECONDS()
			.RunDeactivateRelease = .F.
			.BuildFilter()
			.GridExtraObject.ApplyFilter()
			.GridExtraObject.SetHeaderImages()
			.RELEASE()
		ENDWITH
		
	ENDPROC

	PROCEDURE cmdFilter.GotFocus
		THISFORM.LastUserAction = SECONDS()
		
	ENDPROC

	PROCEDURE cmdSearch.Click
		WITH THISFORM
			.LastUserAction = SECONDS()
			.RunDeactivateRelease = .F.
			.Search()
			.RunDeactivateRelease = .T.
		ENDWITH
		
	ENDPROC

	PROCEDURE cmdSearch.GotFocus
		THISFORM.LastUserAction = SECONDS()
		
	ENDPROC

	PROCEDURE Grid1.AfterRowColChange
		LPARAMETERS nColIndex
		
		THISFORM.LastUserAction = SECONDS()
		
		DODEFAULT(nColIndex)
		
	ENDPROC

	PROCEDURE Grid1.Column1.Check1.Valid
		WITH THISFORM
			.LastUserAction = SECONDS()
			GO RECNO(.UniqueCursorName) IN (.UniqueCursorName) && ensure change makes it to the table
			IF !THIS.VALUE AND .Check1.VALUE
				.Check1.VALUE = .F.
				.Check1.REFRESH()
			ELSE
				.CheckForSelectAll()
				.Grid1.REFRESH()
			ENDIF
			.GridCustomFilter1.ClearFilterSettings()
		ENDWITH
		
	ENDPROC

	PROCEDURE Grid1.Resize
		WITH THIS
			.Column2.WIDTH = MAX(.WIDTH - 45, 20) && JIC we'll make sure this column doesn't get too small or throw error for negative numbers
		ENDWITH
		
	ENDPROC

	PROCEDURE Image1.MouseEnter
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		THIS.PARENT.lblMore.MOUSEENTER(nButton, nShift, nXCoord, nYCoord)
		
	ENDPROC

	PROCEDURE Image1.MouseLeave
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		THIS.PARENT.lblMore.MOUSELEAVE(nButton, nShift, nXCoord, nYCoord)
		
	ENDPROC

	PROCEDURE Image2.Click
		LOCAL ARRAY aTemp(1)
		LOCAL lnRecNo
		
		WITH THISFORM
			.LastUserAction = SECONDS()
			IF USED(.UniqueCursorName)
				m.lnRecNo = IIF(!EOF(.UniqueCursorName), RECNO(.UniqueCursorName), 0)
				REPLACE ALL checked WITH !checked IN (.UniqueCursorName)
				.CheckForSelectAll()
				IF m.lnRecNo > 0
					GO m.lnRecNo IN (.UniqueCursorName)
					.Grid1.Column1.Check1.REFRESH()
				ELSE
					GO BOTTOM IN (.UniqueCursorName)
					IF !EOF(.UniqueCursorName)
						.Grid1.Column1.Check1.REFRESH()
					ENDIF
				ENDIF
				.Grid1.REFRESH()
			ENDIF
			.GridCustomFilter1.ClearFilterSettings()
		ENDWITH
		
	ENDPROC

	PROCEDURE lblMore.Click
		THISFORM.LastUserAction = SECONDS()
		
		WITH THIS
			IF .CAPTION = "More..."
				.CAPTION = "Less..."
				THISFORM.ShowFilterOptions(.T.)
			ELSE
				.CAPTION = "More..."
				THISFORM.ShowFilterOptions(.F.)
			ENDIF
		ENDWITH
		
	ENDPROC

	PROCEDURE lblMore.MouseEnter
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		WITH THIS
			.FONTUNDERLINE = .T.
			.FORECOLOR = RGB(0,0,255)
		ENDWITH
		
	ENDPROC

	PROCEDURE lblMore.MouseLeave
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		WITH THIS
			.FONTUNDERLINE = .F.
			.FORECOLOR = RGB(128,128,255)
		ENDWITH
		
	ENDPROC

	PROCEDURE txtSearch.GotFocus
		THISFORM.LastUserAction = SECONDS()
		
		WITH THIS
			IF .FONTITALIC = .T.
				.VALUE = ""
				.REFRESH()
				.FONTITALIC = .F.
				.FORECOLOR = RGB(0,0,0)
			ENDIF
		ENDWITH
		
	ENDPROC

	PROCEDURE txtSearch.InteractiveChange
		WITH THISFORM
			.LastUserAction = SECONDS()
			.FindNext = .F.
		ENDWITH
		
	ENDPROC

	PROCEDURE txtSearch.KeyPress
		LPARAMETERS nKeyCode, nShiftAltCtrl
		
		IF m.nKeyCode = 13
			NODEFAULT
			THISFORM.cmdSearch.CLICK()
		ENDIF
		
	ENDPROC

	PROCEDURE txtSearch.LostFocus
		WITH THIS
			IF EMPTY(.VALUE)
				.VALUE = "Search"
				.FONTITALIC = .T.
				.FORECOLOR = RGB(128,128,255)
				.REFRESH()
			ENDIF
		ENDWITH
		
	ENDPROC

ENDDEFINE

DEFINE CLASS gridsearchandfiltertoplevel AS gridsearchandfilter OF "gridextras.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	BorderStyle = 3
	DoCreate = .T.
	Height = 382
	Left = 0
	Name = "gridextraformtoplevel"
	ShowInTaskBar = .F.
	ShowWindow = 2
	Top = 0
	Width = 228
	Check1.Alignment = 0
	Check1.Name = "Check1"
	cmdClearFilter.Name = "cmdClearFilter"
	cmdExit.Name = "cmdExit"
	cmdFilter.Name = "cmdFilter"
	cmdSearch.Name = "cmdSearch"
	Grid1.Column1.Check1.Alignment = 0
	Grid1.Column1.Check1.Name = "Check1"
	Grid1.Column1.Header1.Name = "Header1"
	Grid1.Column1.Name = "Column1"
	Grid1.Column2.Header1.Name = "Header1"
	Grid1.Column2.Name = "Column2"
	Grid1.Column2.Text1.Name = "Text1"
	Grid1.Name = "Grid1"
	Gridcustomfilter1.Combo1.Name = "Combo1"
	Gridcustomfilter1.Name = "Gridcustomfilter1"
	Gridcustomfilter1.Text1.Name = "Text1"
	Gridcustomfilter1.Text2.Name = "Text2"
	Image1.Height = 16
	Image1.Name = "Image1"
	Image1.Width = 16
	Image2.Height = 25
	Image2.Name = "Image2"
	Image2.Width = 36
	lblMore.Name = "lblMore"
	shpSplitter.Name = "shpSplitter"
	tmrCheckform.Name = "tmrCheckform"
	tmrFadeform.Name = "tmrFadeform"
	txtSearch.Name = "txtSearch"

ENDDEFINE

DEFINE CLASS gridtemplates AS form 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Shape6" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Shape5" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Image1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cboTemplates" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdAdd" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Label1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdDelete" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdExit" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: addtemplate		&& INTERNAL USE: Used to facilitate the ability for the user to add a new template (create and save) to the table specified by the TemplateTable property of the GridExtra class.
		*m: deletetemplate		&& INTERNAL USE: Used to facilitate the ability for the user to delete an existing template from the table specified by the TemplateTable property of the GridExtra class.
		*m: gettemplates		&& INTERNAL USE: Used to retrieve template records from the table specified by the TemplateTable property of the GridExtra class and fill the cursor specified by the TemplateCursorName of this class.
		*p: gridextrasobject		&& INTERNAL USE: Holds a reference to the GridExtra class instance that called this form.
		*p: gridhierarchy		&& INTERNAL USE: Used to uniquely identify the grid within the the table specified by the TemplateTable property of the GridExtra class. This also allows the retrieval of only those templates that relate to this grid by the GetTemplates method.
		*p: gridobject		&& INTERNAL USE: Holds a reference to target grid to which the templates do and will apply.
		*p: parentform		&& INTERNAL USE: Not currently used, but holds a reference to the THISFORM for the GridExtras class instance that called this form. May be used in future enhancements to this class.
		*p: templatecursorname		&& INTERNAL USE: Holds a unique (unused) cursor name that is used as the alias for the cboTemplates control's rowsource. This alias is filled by way of the GetTemplates method.
	*</DefinedPropArrayMethod>

	AlwaysOnTop = .T.
	AutoCenter = .T.
	Caption = "Grid Templates"
	Desktop = .T.
	DoCreate = .T.
	gridextrasobject = .NULL.		&& INTERNAL USE: Holds a reference to the GridExtra class instance that called this form.
	gridhierarchy = 		&& INTERNAL USE: Used to uniquely identify the grid within the the table specified by the TemplateTable property of the GridExtra class. This also allows the retrieval of only those templates that relate to this grid by the GetTemplates method.
	gridobject = .NULL.		&& INTERNAL USE: Holds a reference to target grid to which the templates do and will apply.
	Height = 250
	Name = "gridutils"
	parentform = .NULL.		&& INTERNAL USE: Not currently used, but holds a reference to the THISFORM for the GridExtras class instance that called this form. May be used in future enhancements to this class.
	templatecursorname = 		&& INTERNAL USE: Holds a unique (unused) cursor name that is used as the alias for the cboTemplates control's rowsource. This alias is filled by way of the GetTemplates method.
	Width = 434

	ADD OBJECT 'cboTemplates' AS combobox WITH ;
		Anchor = 3, ;
		Height = 24, ;
		Left = 109, ;
		Name = "cboTemplates", ;
		Style = 2, ;
		TabIndex = 2, ;
		Top = 74, ;
		Width = 260
		*< END OBJECT: BaseClass="combobox" />

	ADD OBJECT 'cmdAdd' AS commandbutton WITH ;
		Anchor = 3, ;
		Caption = "", ;
		Height = 26, ;
		Left = 369, ;
		Name = "cmdAdd", ;
		Picture = add16.png, ;
		TabIndex = 3, ;
		Top = 73, ;
		Width = 26
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdDelete' AS commandbutton WITH ;
		Anchor = 3, ;
		Caption = "", ;
		Height = 26, ;
		Left = 394, ;
		Name = "cmdDelete", ;
		Picture = delete16.png, ;
		TabIndex = 4, ;
		Top = 73, ;
		Width = 26
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdExit' AS commandbutton WITH ;
		Anchor = 12, ;
		Caption = "Close ", ;
		Height = 32, ;
		Left = 336, ;
		Name = "cmdExit", ;
		Picture = exit.png, ;
		PictureMargin = 2, ;
		PicturePosition = 4, ;
		TabIndex = 6, ;
		Top = 208, ;
		Width = 84
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'Image1' AS image WITH ;
		Height = 48, ;
		Left = 18, ;
		Name = "Image1", ;
		Picture = table_sql_view.png, ;
		Top = 16, ;
		Width = 48, ;
		ZOrderSet = 16
		*< END OBJECT: BaseClass="image" />

	ADD OBJECT 'Label1' AS label WITH ;
		Anchor = 3, ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = "Filter & Sort Templates", ;
		Height = 17, ;
		Left = 109, ;
		Name = "Label1", ;
		TabIndex = 1, ;
		Top = 57, ;
		Width = 127
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'Shape5' AS shape WITH ;
		Anchor = 7, ;
		BackColor = 255,255,255, ;
		Height = 201, ;
		Left = -2, ;
		Name = "Shape5", ;
		SpecialEffect = 0, ;
		Top = -2, ;
		Width = 89, ;
		ZOrderSet = 15
		*< END OBJECT: BaseClass="shape" />

	ADD OBJECT 'Shape6' AS shape WITH ;
		Anchor = 14, ;
		BackStyle = 0, ;
		Height = 56, ;
		Left = -3, ;
		Name = "Shape6", ;
		SpecialEffect = 0, ;
		Top = 197, ;
		Width = 441, ;
		ZOrderSet = 8
		*< END OBJECT: BaseClass="shape" />
	
	PROCEDURE addtemplate		&& INTERNAL USE: Used to facilitate the ability for the user to add a new template (create and save) to the table specified by the TemplateTable property of the GridExtra class.
		LOCAL llReturn, lcTemplateName
		
		m.llReturn = .F.
		m.lcTemplateName = INPUTBOX("Template Name", "New Filter & Export Template", "")
		IF !EMPTY(m.lcTemplateName)
			THISFORM.gridextrasobject.templatesave(THISFORM.gridhierarchy, m.lcTemplateName)
			m.llReturn = .T.
		ENDIF
		
		RETURN (m.llReturn)
		
	ENDPROC

	PROCEDURE deletetemplate		&& INTERNAL USE: Used to facilitate the ability for the user to delete an existing template from the table specified by the TemplateTable property of the GridExtra class.
		LOCAL lcTemplateName
		
		IF !EMPTY(THISFORM.cboTemplates.DISPLAYVALUE)
			IF MESSAGEBOX("Are you sure you want to delete the '" + ALLTRIM(THISFORM.cboTemplates.DISPLAYVALUE) + "' template?",36,"Confirmation Required") = 6
				m.lcTemplateName = UPPER(ALLTRIM(THISFORM.gridhierarchy)) + ":" + ALLTRIM(THISFORM.cboTemplates.DISPLAYVALUE)
				THISFORM.gridextrasobject.templatedelete(m.lcTemplateName)
			ENDIF
			THISFORM.GetTemplates()
		ENDIF
		
	ENDPROC

	PROCEDURE gettemplates		&& INTERNAL USE: Used to retrieve template records from the table specified by the TemplateTable property of the GridExtra class and fill the cursor specified by the TemplateCursorName of this class.
		LOCAL lcTemplateTable, lcTemplateTableJustStem
		
		m.lcTemplateTable = EVALUATE(THIS.gridextrasobject.templatetable)
		m.lcTemplateTableJustStem = JUSTSTEM(m.lcTemplateTable)
		IF TYPE("m.lcTemplateTable") = "C" AND FILE(m.lcTemplateTable)
			IF !USED(m.lcTemplateTableJustStem)
				USE (m.lcTemplateTable) IN 0 SHARED
			ENDIF
			THISFORM.cboTemplates.ROWSOURCE = ""
			SELECT Template FROM (m.lcTemplateTableJustStem) WHERE .F. INTO CURSOR (THISFORM.templatecursorname) READWRITE
			INSERT INTO (THISFORM.templatecursorname) VALUES ("")
			INSERT INTO (THISFORM.templatecursorname) ;
				SELECT Template FROM (m.lcTemplateTableJustStem) ;
				WHERE !DELETED() AND UPPER(ALLTRIM(gridname)) == UPPER(ALLTRIM(THISFORM.gridhierarchy)) ;
				ORDER BY 1
			GO TOP IN (THISFORM.templatecursorname)
			THISFORM.cboTemplates.ROWSOURCE = THISFORM.templatecursorname
			THISFORM.cboTemplates.ROWSOURCETYPE = 2
			THISFORM.cboTemplates.DISPLAYVALUE = ""
			THISFORM.cboTemplates.REFRESH()
		ENDIF
		
	ENDPROC

	PROCEDURE Init
		LPARAMETERS toParentForm, toGridObject, toGridExtrasObject
		
		WITH THIS
			.TemplateCursorName = SYS(2015)
			.ICON = _SCREEN.ICON
			.parentform = m.toParentForm
			.gridobject = m.toGridObject
			.gridhierarchy = SYS(1272, m.toGridObject)
			.gridextrasobject = m.toGridExtrasObject
			.GetTemplates()
			.shape5.ZORDER(1)
			.shape6.ZORDER(1)
		ENDWITH
		
	ENDPROC

	PROCEDURE Load
		IF FILE("gridextrasprocs.prg")
			SET PROCEDURE TO gridextrasprocs.prg ADDITIVE
		ENDIF
		
	ENDPROC

	PROCEDURE QueryUnload
		NODEFAULT
		
		THISFORM.cmdExit.CLICK()
		
	ENDPROC

	PROCEDURE Unload
		USE IN SELECT(this.templatecursorname)
	ENDPROC

	PROCEDURE cboTemplates.InteractiveChange
		LOCAL loColumnObject, loHeaderObject
		
		WITH THISFORM.gridextrasobject
			IF !EMPTY(THIS.DISPLAYVALUE) && Apply the selected template
				.templateapply(UPPER(ALLTRIM(THISFORM.gridhierarchy)) + ":" + ALLTRIM(THIS.DISPLAYVALUE))
			ELSE && Clear out any filter or sort applied by a previous template selection
				DIMENSION .acolumnfilters(1, 3)
				STORE .F. TO .acolumnfilters
				DIMENSION .customcolumnfilters(1, 3)
				STORE .F. TO .customcolumnfilters
				.clearfilter()
				.applysort()
				FOR EACH loColumnObject IN .gridobject.COLUMNS
					m.loHeaderObject = m.loColumnObject.CONTROLS(1)
					STORE '' TO  m.loHeaderObject.PICTURE, m.loHeaderObject.TAG
				ENDFOR
			ENDIF
		ENDWITH
		
		THIS.SETFOCUS()
		
	ENDPROC

	PROCEDURE cmdAdd.Click
		IF THISFORM.addtemplate()
			THISFORM.getTemplates()
		ENDIF
		
	ENDPROC

	PROCEDURE cmdDelete.Click
		IF THISFORM.cboTemplates.LISTINDEX > 1
			THISFORM.deletetemplate()
		ENDIF
		
	ENDPROC

	PROCEDURE cmdExit.Click
		THISFORM.RELEASE()
		
	ENDPROC

ENDDEFINE

DEFINE CLASS gridtemplatestoplevel AS gridtemplates OF "gridextras.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	Desktop = .F.
	DoCreate = .T.
	Name = "gridutilstoplevel"
	ShowWindow = 2
	cboTemplates.Name = "cboTemplates"
	cmdAdd.Name = "cmdAdd"
	cmdDelete.Name = "cmdDelete"
	cmdExit.Name = "cmdExit"
	Image1.Height = 48
	Image1.Name = "Image1"
	Image1.Width = 48
	Label1.Name = "Label1"
	Shape5.Name = "Shape5"
	Shape6.Name = "Shape6"

ENDDEFINE
